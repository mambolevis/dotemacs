#+TITLE: Emacs Configuration
#+AUTHOR: Colin McLear

This is my emacs configuration file. I use org-mode to organize it and then
"tangle" the file using org-babel. You can find a helpful discussion of this
method [[http://stackoverflow.com/questions/17416738/emacs-initialization-as-org-file-how-can-i-get-the-right-version-of-org-mode][here]]. 

I use emacs for all my academic work. The configuration tends in that direction,
as opposed to programming or literary work. If you don't tend to want to think
about your text editor, but like emacs, I strongly recommend [[http://spacemacs.org][spacemacs]] as a way
of managing your configuration. For a more traditional emacs feel there are also
the configurations of [[https://github.com/purcell/emacs.d][purcell]] and [[https://github.com/bbatsov/prelude][batsov (prelude)]]. For a minimally sane setup
you might also look at [[https://github.com/hrs/sensible-defaults.el][sensible defaults]].

* Installing Emacs

On OS X, which I use, [[http://brew.sh/][homebrew]] is an easy way to install emacs. I use the [[https://github.com/railwaycat/homebrew-emacsmacport][emacs
mac port]] version, which has a variety of options set that make for smoother
running on OS X. The one downside is that it loads a bit slower than regular
emacs. If you use the bleeding edge version it might be a bit snappier than the
=emacs-mac= version. However, I've found that the regular =emacs= 24.5 doesn't work
well on OS X and 25 is still a bit unstable. For more info on the various
configurations use =brew info=.

Here's what some example parameters mean.
- ~--with-cocoa~ :: installs emacs with the OS X GUI version
- ~--with-imagemagick~ :: installs emacs with imagemagick support for image processing
- ~--with-gnutls~ :: installs emacs with GnuTLS to utilize encrypted SSL and TLS connections
     
For =emacs-mac= use:

#+BEGIN_SRC sh :tangle no
brew install emacs-mac --with-gnutls --with-imagemagick --with-librsvg
#+END_SRC
     
For =emacs 25= use the following:

#+BEGIN_SRC sh :tangle no
brew install emacs --with-cocoa --HEAD --use-git-head --devel --with-gnutls --with-imagemagick --with-librsvg
#+END_SRC

* Personal Information
Tell emacs who you are. 

#+begin_src emacs-lisp
(setq user-full-name "Colin McLear"
      user-mail-address "mclear@fastmail.com")
#+end_src

* Default settings
Let's use sane defaults. Sources for this section include [[https://github.com/magnars/.emacs.d/blob/master/settings/sane-defaults.el][Magnars Sveen]] and [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]].
** Environment settings
Make sure emacs correctly sets up your PATH.
#+BEGIN_SRC emacs-lisp
  (defvar cpm-local-bin (concat (getenv "HOME") "/bin") "Local execs.")
  (defvar usr-local-bin "/usr/local/bin")
  (setenv "PATH" (concat usr-local-bin ":" (getenv "PATH") ":" cpm-local-bin))
  (setq exec-path (append exec-path (list cpm-local-bin usr-local-bin)))
#+END_SRC 

** Don't send to debug on error
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error nil)
#+END_SRC 

** Spelling
Use flyspell and aspell
#+BEGIN_SRC emacs-lisp
  (setq flyspell-issue-welcome-flag nil)
  (if (eq system-type 'darwin)
      (setq-default ispell-program-name "/usr/local/bin/aspell")
    (setq-default ispell-program-name "/usr/bin/aspell"))
  (setq-default ispell-list-command "list")
#+END_SRC 
 
** Deal with warnings
No bells and no visible "bell" either!
#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil) ;; The default
  (setq ring-bell-function 'ignore)
#+END_SRC

** Frame startup size and position
I like the frame centered and approximately 2/3 of a 13inch laptop screen.
#+BEGIN_SRC emacs-lisp
  ;; Set Frame width/height
  (setq default-frame-alist
        '((top . 25) (left . 275) (width . 105) (height . 60)))
#+END_SRC

** Name frame
Show the filepath in the frame title.
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '(" "
      (buffer-file-name "%f"
      (dired-directory dired-directory "%b"))))
#+END_SRC

** Get rid of UI cruft
Turn off all of the GUI cruft.
#+BEGIN_SRC emacs-lisp
  ;; Turn off mouse interface early in startup to avoid momentary display
  (when window-system
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (tooltip-mode -1))
#+END_SRC

** No menu bar in terminal
Ditto for the terminal.
#+BEGIN_SRC emacs-lisp
  (when (not (display-graphic-p))
    (menu-bar-mode -1))
#+END_SRC

** Start from scratch
Start up with a clean scratch buffer.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")
#+END_SRC

** Start scratch in text mode 
Useful to get a faster Emacs load time because it avoids autoloads of elisp modes
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'text-mode)
#+END_SRC

** These functions are useful. Activate them.
#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

** Answering just 'y' or 'n' will do
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** UTF-8 please
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8) 
  (set-terminal-coding-system 'utf-8) 
  (set-keyboard-coding-system 'utf-8) 
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8) 
#+END_SRC

** Turn off the blinking cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC

** Only use spaces
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
  (setq-default indicate-empty-lines nil)
#+END_SRC

** Don't count two spaces after a period as the end of a sentence.
#+BEGIN_SRC emacs-lisp
  ;; Just one space is needed.
  (setq sentence-end-double-space nil)
#+END_SRC

** Delete the region when typing, just like as we expect nowadays.
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC

** Show matching parens
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
#+END_SRC

** Line wrap
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode)
 ;; (diminish 'visual-line-mode)
#+END_SRC

** Give buffers unique names
#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Bash aliases 
-i gets alias definitions from .bash_profile
#+BEGIN_SRC emacs-lisp
  (setq shell-command-switch "-ic")
#+END_SRC

* Settings
** Backups
#+BEGIN_SRC emacs-lisp
 (setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
    (setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
(setq make-backup-files t               ; backup of a file the first time it is saved.
      backup-by-copying t               ; don't clobber symlinks
      version-control t                 ; version numbers for backup files
      delete-old-versions t             ; delete excess backup files silently
      delete-by-moving-to-trash t
      kept-old-versions 4               ; oldest versions to keep when a new numbered backup is made
      kept-new-versions 6               ; newest versions to keep when a new numbered backup is made
      auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      )
#+END_SRC
*** Auto Save
I make sure Emacs auto-saves often but the result is that it messes up my file tree. So, let's ask Emacs to store its backups in the temporary directory.

#+BEGIN_SRC emacs-lisp
(setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
      create-lockfiles nil)
#+END_SRC

*** Full Auto Save
I also make emacs just outright save all buffers. 
#+BEGIN_SRC emacs-lisp
  (defun full-auto-save ()
    (interactive)
    (save-excursion
      (dolist (buf (buffer-list))
        (set-buffer buf)
        (if (and (buffer-file-name) (buffer-modified-p))
            (basic-save-buffer)))))
  (add-hook 'auto-save-hook 'full-auto-save)
#+END_SRC
** Custom file settings
Set up the customize file to its own separate file, instead of saving
customize settings in [[file:init.el][init.el]].

#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
** Text settings
Center the cursor, and line numbers for programming modes.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'centered-cursor-mode)
  (add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC
** OSX settings
There are configurations to make when running Emacs on OS X (hence the
"darwin" system-type check).

#+begin_src emacs-lisp
  (let ((is-mac (string-equal system-type "darwin")))
    (when is-mac
      ;; delete files by moving them to the trash
      (setq delete-by-moving-to-trash t)
      (setq trash-directory "~/.Trash")

      ;; Don't make new frames when opening a new file with Emacs
      (setq ns-pop-up-frames nil)

      ;; Set modifier keys
      (setq mac-option-modifier 'meta) ;; Bind meta to ALT
      (setq mac-command-modifier 'super) ;; Bind apple/command to super if you want
      (setq mac-function-modifier 'hyper) ;; Bind function key to hyper if you want 
      (setq mac-right-option-modifier 'none) ;; unbind right key for accented input

      ;; Make forward delete work 
      (global-set-key (kbd "<H-backspace>") 'delete-forward-char)
    
      ;; Keybindings
      (global-set-key (kbd "s-=") 'scale-up-font)
      (global-set-key (kbd "s--") 'scale-down-font)
      (global-set-key (kbd "s-0") 'reset-font-size)
      (global-set-key (kbd "s-q") 'save-buffers-kill-terminal)
      (global-set-key (kbd "s-v") 'yank)
      (global-set-key (kbd "s-c") 'evil-yank)
      (global-set-key (kbd "s-a") 'mark-whole-buffer)
      (global-set-key (kbd "s-x") 'kill-region)
      (global-set-key (kbd "s-w") 'delete-window)
      (global-set-key (kbd "s-W") 'delete-frame)
      (global-set-key (kbd "s-n") 'make-frame)
      (global-set-key (kbd "s-z") 'undo-tree-undo)
      (global-set-key (kbd "s-s")
                      (lambda ()
                        (interactive)
                        (call-interactively (key-binding "\C-x\C-s"))))
      (global-set-key (kbd "s-Z") 'undo-tree-redo)
      (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)
      ;; Emacs sometimes registers C-s-f as this weird keycode
      (global-set-key (kbd "<C-s-268632070>") 'toggle-frame-fullscreen)
  ))
   
      (defun open-dir-in-iterm ()
        "Open the current directory of the buffer in iTerm."
        (interactive)
        (let* ((iterm-app-path "/Applications/iTerm.app")
               (iterm-brew-path "/opt/homebrew-cask/Caskroom/iterm2/2.1.4/iTerm.app")
               (iterm-path (if (file-directory-p iterm-app-path)
                               iterm-app-path
                             iterm-brew-path)))
          (shell-command (concat "open -a " iterm-path " ."))))

      ;; Not going to use these commands
      (put 'ns-print-buffer 'disabled t)
      (put 'suspend-frame 'disabled t)
#+end_src
** Other settings
#+BEGIN_SRC emacs-lisp
  ;; Keep focus while navigating help buffers
  (setq help-window-select 't)

  ;; highlight current line
  (global-hl-line-mode t)

  ;; Save clipboard contents into kill-ring before replace them
  (setq save-interprogram-paste-before-kill t)

  ;; Single space between sentences is more widespread than double
  (setq-default sentence-end-double-space nil)
#+END_SRC
** Tangle on save

This was taken from [[https://github.com/alanpearce/dotfiles/blob/master/tag-emacs/emacs.d/init.org#tangling][Alan Pearce's dotfiles]] so as to tangle the dotfile on save instead of tangling it every time I open it again.

#+BEGIN_SRC emacs-lisp
(defun tangle-if-init ()
  "If the current buffer is 'config.org' the code-blocks are
    tangled, and the tangled file is compiled."

  (when (string-suffix-p "config.org" (buffer-file-name))
    (tangle-init)))

(defun tangle-init-sync ()
  (interactive)
  (message "Tangling init")
  ;; Avoid running hooks when tangling.
  (let ((prog-mode-hook nil)
        (src  (expand-file-name "config.org" user-emacs-directory))
        (dest (expand-file-name "config.el"  user-emacs-directory)))
    (require 'ob-tangle)
    (org-babel-tangle-file src dest)
    (if (byte-compile-file dest)
        (byte-compile-dest-file dest)
      (with-current-buffer byte-compile-log-buffer
        (buffer-string)))))

(defun tangle-init ()
  "Tangle init.org asynchronously."

  (interactive)
  (message "Tangling init")
  (async-start
   (symbol-function #'tangle-init-sync)
   (lambda (result)
     (message "Init tangling completed: %s" result))))
#+END_SRC

** Add some useful libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing, string manipulation, list manipulation and backward compatibility respectively.

#+BEGIN_SRC emacs-lisp
(use-package async
  :defer 2
  :ensure t
  :commands (async-start))

(use-package cl-lib
  :ensure t)

(use-package dash
  :ensure t)

(use-package s
  :ensure t)
#+END_SRC

* Evil Mode
  I'm coming from vim, and want modal keybidings in emacs. There are other, less
  radical ways of getting modal editing in emacs. For example, [[https://github.com/mrkkrp/modalka][modalka]] is a nice
  package for modal editing. But nothing beats full vim keybindings. And that is
  what [[https://bitbucket.org/lyro/evil/wiki/Home][evil]] is for.

** Basic setup
The essential stuff
#+begin_src emacs-lisp :tangle yes
  (use-package evil
    :ensure t
    :init
    (progn
    ;; Cursor shape and color
      (defcustom dotemacs-evil/emacs-cursor
      "red"
      "The color of the cursor when in Emacs state."
      :type 'color
      :group 'dotemacs-evil)

      (defcustom dotemacs-evil/emacs-insert-mode
      nil
      "If non-nil, insert mode will act as Emacs state."
      :type 'boolean
      :group 'dotemacs-evil)

      (setq evil-search-module 'evil-search)
      (setq evil-magic 'very-magic)

      (setq evil-emacs-state-cursor `(,dotemacs-evil/emacs-cursor box))
      (setq evil-normal-state-cursor '("DarkGoldenrod2" box))
      (setq evil-visual-state-cursor '("gray" box)) 
      (setq evil-insert-state-cursor '("chartreuse3" (bar . 2)))
      (setq evil-replace-state-cursor '("red" hbar))
      (setq evil-operator-state-cursor '("red" hollow))
      (use-package evil-escape
        :ensure t
        :diminish ""
        :init
        (evil-escape-mode)
        ;; use "fd" for escape
        (setq-default evil-escape-key-sequence "fd")
        (use-package evil-indent-textobject :ensure t)
        (use-package evil-leader
          :ensure t
          :init
          (defun switch-to-previous-buffer ()
          (interactive)
          (switch-to-buffer (other-buffer (current-buffer) 1)))
          ;; leader basic shortcuts
          ;; I have to include some here but the rest are under "General" in the "Keybindings" section below.
          (evil-leader/set-key
          "A" 'helm-apropos)
          ;; evil-normal-state is preferred, so revert when idle
          (run-with-idle-timer 20 t 'evil-normal-state)

          ;; the order of the following is important!

          ;; (setq evil-leader/in-all-states t)
          (setq evil-leader/non-normal-prefix "")
          (evil-leader/set-leader "<SPC>")
          (evil-mode nil) ;; no idea
          (global-evil-leader-mode)
          (evil-mode 1)))))
#+end_src

#+RESULTS:

** Evil packages & settings
There are some other useful setup packages for evil
*** Navigate Using Visual Lines Rather Than True Lines
#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
#+end_src

*** Increment And Decrement Numbers
#+begin_src emacs-lisp
  (use-package evil-numbers
    :ensure t
    :defer t
    :init
    (progn
      (bind-key "H-s" 'evil-numbers/inc-at-pt evil-normal-state-map)
      (bind-key "H-a" 'evil-numbers/dec-at-pt evil-normal-state-map)))
#+end_src

*** Change Cursor In Terminal
#+begin_src emacs-lisp
(defun my-send-string-to-terminal (string)
  (unless (display-graphic-p) (send-string-to-terminal string)))

(defun my-evil-terminal-cursor-change ()
  (when (string= (getenv "TERM_PROGRAM") "iTerm.app")
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\e]50;CursorShape=1\x7")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\e]50;CursorShape=0\x7"))))
  (when (and (getenv "TMUX") (string= (getenv "TERM_PROGRAM") "iTerm.app"))
    (add-hook 'evil-insert-state-entry-hook (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=1\x7\e\\")))
    (add-hook 'evil-insert-state-exit-hook  (lambda () (my-send-string-to-terminal "\ePtmux;\e\e]50;CursorShape=0\x7\e\\")))))

(add-hook 'after-make-frame-functions (lambda (frame) (my-evil-terminal-cursor-change)))
(my-evil-terminal-cursor-change)

  (use-package evil-terminal-cursor-changer
    :ensure t
    :disabled t
    :defer t
    :init
     (unless (display-graphic-p)
             (require 'evil-terminal-cursor-changer)
    (progn 
     (setq evil-visual-state-cursor '("red" box)); █
     (setq evil-insert-state-cursor '("green" bar)); ⎸
     (setq evil-emacs-state-cursor '("blue" hbar)); _
     )))
#+end_src

*** Motions And Text Objects For Delimited Arguments
#+begin_src emacs-lisp
  (use-package evil-args
    :ensure t
    :defer t
    :config
    ;; bind evil-args text objects
    (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
    (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)

    ;; bind evil-forward/backward-args
    (define-key evil-normal-state-map "L" 'evil-forward-arg)
    (define-key evil-normal-state-map "H" 'evil-backward-arg)
    (define-key evil-motion-state-map "L" 'evil-forward-arg)
    (define-key evil-motion-state-map "H" 'evil-backward-arg)

    ;; bind evil-jump-out-args
    (define-key evil-normal-state-map "K" 'evil-jump-out-args)
    )
#+end_src

*** Surround Commands Like Vim-Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :ensure t
    :defer t
    :commands (evil-surround-region)
    :init 
    (progn 
      (global-evil-surround-mode 1)
      (evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region)
      (evil-define-key 'visual evil-surround-mode-map "S" 'evil-substitute)))
#+end_src 

*** Commenting 
#+begin_src emacs-lisp
  (use-package evil-commentary
    :ensure t
    :defer t
    :commands (evil-commentary evil-commentary-line)
    :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
#+end_src

*** Graphical undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :defer 2
    :init
    (progn
      (setq undo-tree-mode-lighter "")
      (setq undo-tree-auto-save-history t)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)
      (setq undo-tree-history-directory-alist `((".*" . ,temporary-file-directory))))
    :config
    (global-undo-tree-mode)
    )
#+end_src
* Theme
** Solarized
The best low-contrast theme out there.
#+BEGIN_SRC emacs-lisp
  (if (display-graphic-p)
      (use-package solarized-theme
        :ensure t
        :defer t
        ;; :disabled t
        :init
        (progn
        ;; make the fringe stand out from the background
        (setq solarized-distinct-fringe-background nil)

        ;; change the font for some headings and titles
        (setq solarized-use-variable-pitch t)

        ;; make the modeline high contrast
        (setq solarized-high-contrast-mode-line t)

        ;; Use bolding
        (setq solarized-use-less-bold nil)

        ;; Use more italics
        (setq solarized-use-more-italic t)

        ;; Use colors for indicators such as git:gutter, flycheck and similar
        (setq solarized-emphasize-indicators t)

        ;; Don't change size of org-mode headlines (but keep other size-changes)
        (setq solarized-scale-org-headlines t)

        (load-theme 'solarized-dark t)

    ))
(load-theme 'wombat t))

        ;; Avoid all font-size changes
        ;; (setq solarized-height-minus-1 1)
        ;; (setq solarized-height-plus-1 1)
        ;; (setq solarized-height-plus-2 1)
        ;; (setq solarized-height-plus-3 1)
        ;; (setq solarized-height-plus-4 1))

  ;; An alternative solarized theme
    (use-package color-theme-sanityinc-solarized
      :ensure t
      :disabled t
      :init
         (progn
            (load-theme 'sanityinc-solarized-dark t)))

#+END_SRC

#+RESULTS:
** Gruvbox theme
   This is a great general-purpose theme
   #+begin_src emacs-lisp
     (use-package gruvbox-theme
       :ensure t 
       :disabled t
       :init
       (load-theme 'gruvbox t))
   #+end_src
** Darktooth theme
   Similar to gruvbox
      #+begin_src emacs-lisp
      (use-package darktooth-theme
        :ensure t
        :defer t
        :disabled t
       (load-theme 'darktooth t))
      #+end_src
** Zenburn 
Another popular low-contrast theme
#+BEGIN_SRC emacs-lisp
  (use-package zenburn
    :ensure t
    :disabled t
    :init
    (progn
      (load-theme 'zenburn t)))
#+END_SRC

There is also a higher contrast version
#+BEGIN_SRC emacs-lisp
  (use-package hc-zenburn
    :ensure t
    :disabled t
    :init
    (progn
      (load-theme 'hc-zenburn t)))
#+END_SRC

** Material theme
#+BEGIN_SRC emacs-lisp
(use-package material-theme
  :ensure t
  :defer t
  :commands material-theme)
#+END_SRC

** Badger
A dark and relatively high-contrast theme
#+BEGIN_SRC emacs-lisp
  (use-package badger-theme
    :ensure t
    :disabled t
    :init
    (progn
      (load-theme 'badger t)))
#+END_SRC
** Convenient theme functions
#+begin_src emacs-lisp
(use-package helm-themes
  :ensure t
  :defer t
  :commands helm-themes) 
#+end_src
* Font
  
[[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] is a nice monospaced font.

To install it on OS X, you can use Homebrew with [[http://caskroom.io/][Homebrew Cask]].

#+begin_src sh :tangle no
# You may need to run these two lines if you haven't set up Homebrew
# Cask and its fonts formula.
brew install caskroom/cask/brew-cask
brew tap caskroom/fonts
brew cask install font-inconsolata
#+end_src

And here's how we tell Emacs to use the font we want to use.

#+begin_src emacs-lisp
(set-face-attribute 'default nil
                    :family "Inconsolata LGC"
                    :height 120
                    :weight 'normal
                    :width 'normal
                    )
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
;; C-x C-0 restores the default font size
#+end_src
* Line numbers
#+BEGIN_SRC emacs-lisp
; Turn on line numbers for hooked modes
(add-hook 'prog-mode-hook 'linum-mode)
(add-hook 'markdown-mode-hook 'linum-mode)
;; line number spacing
(setq linum-format "%4d ")
;; Highlight current line number
  (defvar linum-current-line 1 "Current line number.")
  (defvar linum-border-width 1 "Border width for linum.")

  (defface linum-current-line
  `((t :inherit linum
      :foreground "goldenrod"
      :weight bold
      ))
  "Face for displaying the current line number."
  :group 'linum)

  (defadvice linum-update (before advice-linum-update activate)
  "Set the current line."
  (setq linum-current-line (line-number-at-pos)
      ;; It's the same algorithm that linum dynamic. I only had added one
      ;; space in front of the first digit.
      linum-border-width (number-to-string
                          (+ 1 (length
                                  (number-to-string
                                  (count-lines (point-min) (point-max))))))))

  (defun linum-highlight-current-line (line-number)
  "Highlight the current line number using `linum-current-line' face."
  (let ((face (if (= line-number linum-current-line)
                  'linum-current-line
              'linum)))
  (propertize (format (concat "%" linum-border-width "d") line-number)
              'face face)))

  (setq linum-format 'linum-highlight-current-line)
#+END_SRC

* Org
[[http://orgmode.org][Org-mode]] is really why most people use emacs. Here are some basic settings and packages.
** Base settings
#+BEGIN_SRC emacs-lisp
(use-package org 
  :defer t
  :init
  (progn
    (setq org-src-fontify-natively t ;; better looking source code
          org-hide-emphasis-markers t  ;; hide markers
          org-pretty-entities t ;; make latex look good
          org-fontify-quote-and-verse-blocks t ;; make quotes stand out
          org-table-export-default-format "orgtbl-to-csv" ;; export for org-tables to csv
          org-return-follows-link t ;; make RET follow links
          org-ellipsis "↴"  ;; nicer elipses
          org-confirm-babel-evaluate nil  ;; evaluate src block without confirmation           
          org-startup-indented t ;; start in indent mode
          ; org-src-preserve-indentation nil 
          ; org-edit-src-content-indentation t
          )
    (evil-define-key 'insert org-mode-map (kbd "\t") nil)
    ;; Open with return in evil
    (evil-define-key 'normal org-mode-map (kbd "RET") 'org-open-at-point)
    ;; imenu and org settings
    (add-hook 'org-mode-hook
        (lambda () 
          (turn-on-auto-fill)
          (set-fill-column 80)
          (centered-cursor-mode)
          (flyspell-mode 1)
          (global-git-gutter+-mode 0)
          (imenu-add-to-menubar "Imenu")))
    (setq org-imenu-depth 4)
    (setq imenu-auto-rescan t)
    ;; add org mode evil keybindings
    (add-hook 'org-mode-hook #'cpm/org-keybindings)
          )
    :config
      (progn
        (use-package evil-org
          :defer t
          :disabled t
          :ensure t
          :diminish ""
          :commands evil-org-mode
          :init
          (add-hook 'org-mode-hook 'evil-org-mode)
          :config
          (progn
          ;; fix a couple annoying keybindings in evil-org
          (evil-define-key 'normal evil-org-mode-map
            "O" 'evil-open-above
            "J" 'evil-join)))
        (use-package ox-pandoc
          :defer t
          :ensure t
          :commands ox-pandoc
          :init
          (with-eval-after-load 'org)
            (require 'ox-pandoc))
        (use-package org-bullets
          :defer t
          :ensure t
          :init (add-hook 'org-mode-hook 'org-bullets-mode))
        (use-package htmlize
          :defer t :ensure t)
        (use-package toc-org
          :ensure t
          :defer t
          :init
          (progn
            (setq toc-org-max-depth 10)
            (add-hook 'org-mode-hook 'toc-org-enable)))
     ))
#+END_SRC
** Org hooks
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda()
               (turn-on-auto-fill) (set-fill-column 80) (flyspell-mode 1) (hl-todo-mode) (imenu-add-to-menubar "Imenu") (global-git-gutter+-mode 0)))
#+END_SRC
** Org publish
#+BEGIN_SRC emacs-lisp

  ;;; Org and website (pelican)
     (with-eval-after-load 'org
     (org-add-link-type
      "pelican"
      (lambda (path) (org-open-file path))
      ;; ; export
      (lambda (path desc backend)
        (cond
         ((eq backend 'org)
          (format "[[file:{filename}/%s][%s]]" path (or desc "")))
         ((eq backend 'html)
          (format "<a href=\"%s\">%s</a>" path (or desc "")))
         ((eq backend 'md)
          (format "[{filename}/%s](%s)" path (or desc "")))))))

   ;;; Org-publish settings
       (setq org-publish-project-alist
         '(
           ("notebook"
            ;; Path to org files
            ;; :base-directory "~/Dropbox/Notes/ResearchNotes"
            :base-directory "~/projects/notebook/content/org_notes"
            :base-extension "org"
            ;; Path to pelican project
            :publishing-directory "~/projects/notebook/content/notes" 
            ;; settings
            :author "Colin McLear"
            :email "mclear@unl.edu"
            :recursive t
            :auto-sitemap nil
            :auto-preamble nil ;; Don't add any kind of html before the content
            :export-with-tags nil
            :with-timestamps nil
            :time-stamp-file nil
            :with-creator nil
            :auto-postamble nil ;; Don't add any kind of html after the content
            :html-postamble nil ;; same thing
            ;; :preparation-function (pandoc-filter)
            ;; :publishing-function (org-html-publish-to-html)
            ;; :publishing-function (org-md-publish-to-md)
            :publishing-function (org-org-publish-to-org)
            ;; :publishing-function (org-pandoc-publish-to-html)
            )
           ))

       (defun org-pandoc-publish-to-html (plist filename pub-dir)
         "Publish an org file to html using ox-pandoc. Return output file name."
         (org-publish-org-to 'org-pandoc-export-to-html filename ".html" plist pub-dir))
#+END_SRC

** Org pomodoro
Helps with time tracking
#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :defer t
    :ensure t
    :init
    (progn
      (setq org-pomodoro-audio-player "/usr/bin/afplay")))
#+END_SRC emacs-lisp
** open docx files in default application (ie msword)
Open exported docx files in Word/Open Office rather than emacs
#+BEGIN_SRC emacs-lisp
  (setq org-file-apps
        '(("\\.docx\\'" . default)
          ("\\.mm\\'" . default)
          ("\\.x?html?\\'" . default)
          ("\\.pdf\\'" . default)
          (auto-mode . emacs)))
#+END_SRC
* Research 
Packages I use for research.
** Helm-Bibtex
Great for managing citations and notes
#+begin_src emacs-lisp :tangle yes
  (use-package helm-bibtex
    :defer t
    :ensure t
    :after helm
    :commands helm-bibtex
    :config
    (setq bibtex-completion-bibliography "/Users/Roambot/Dropbox/Work/Master.bib"
          bibtex-completion-library-path "/Users/Roambot/Dropbox/Work/MasterLib/"
          bibtex-completion-pdf-field "File"
          bibtex-completion-notes-path "/Users/Roambot/Dropbox/Notes/ResearchNotes/"
          bibtex-completion-additional-search-fields '(keywords)
          bibtex-completion-notes-extension ".org"
          helm-bibtex-full-frame nil) ;; Set insert citekey with markdown citekeys for org-mode
    (setq bibtex-completion-format-citation-functions
          '((org-mode    . bibtex-completion-format-citation-pandoc-citeproc)
          (latex-mode    . bibtex-completion-format-citation-cite)
          (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
          (default       . bibtex-completion-format-citation-default)))
    ;; Set default action for helm-bibtex as inserting citation
    (helm-delete-action-from-source "Insert citation" helm-source-bibtex)
    (helm-add-action-to-source "Insert citation" 'helm-bibtex-insert-citation helm-source-bibtex 0)
    (setq bibtex-completion-pdf-symbol "⌘")
    (setq bibtex-completion-notes-symbol "✎")
    )

  ;; Set global shortcut for calling helm-bibtex
   (global-set-key (kbd "H-b") 'helm-bibtex)
#+end_src

** Interleave
Useful when taking notes
#+BEGIN_SRC emacs-lisp
(use-package interleave
  :ensure t
  :defer t
  :init
  (progn
    (with-eval-after-load 'doc-view
      (bind-key "i" #'interleave--open-notes-file-for-pdf doc-view-mode-map))
    (with-eval-after-load 'pdf-view
      (bind-key "i" #'interleave--open-notes-file-for-pdf pdf-view-mode-map)))
   :config
     (with-eval-after-load 'doc-view
     ;; In continuous mode, reaching the page edge advances to the next/prev page
       (setq doc-view-continuous t))
  )
#+END_SRC
** PDF Tools
Better than doc-view, but doesn't render well on retina screens :(
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :defer t
    :ensure t
    :mode (("\\.pdf$" . pdf-view-mode))
    :config
    (progn
      (pdf-tools-install)

  (evil-define-key 'normal pdf-view-mode-map
          ;; Navigation
          "j"  'pdf-view-next-line-or-next-page
          "k"  'pdf-view-previous-line-or-previous-page
          "l"  'image-forward-hscroll
          "h"  'image-backward-hscroll
          "J"  'pdf-view-next-page
          "K"  'pdf-view-previous-page
          "gg"  'pdf-view-first-page
          "G"  'pdf-view-last-page
          "gt"  'pdf-view-goto-page
          "gl"  'pdf-view-goto-label
          "u" 'pdf-view-scroll-down-or-previous-page
          "d" 'pdf-view-scroll-up-or-next-page
          (kbd "C-u") 'pdf-view-scroll-down-or-previous-page
          (kbd "C-d") 'pdf-view-scroll-up-or-next-page
          (kbd "``")  'pdf-history-backward
          ;; Search
          "/" 'isearch-forward
          "?" 'isearch-backward
          ;; Actions
          "r"   'pdf-view-revert-buffer
          "o"   'pdf-links-action-perform
          "O"   'pdf-outline
          )

      (evil-define-key 'insert pdf-view-mode-map
          "y" 'pdf-view-kill-ring-save )
      ;; for annotation and jumping to file
      (eval-after-load 'org '(require 'org-pdfview))
      (add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
      (add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open))
      ;; Extracting annotations using pdf-tools
      ;; modified from https://github.com/politza/pdf-tools/pull/133 
      ;; taken from http://matt.hackinghistory.ca/2015/11/11/note-taking-with-pdf-tools/

      (defun mwp/pdf-multi-extract (sources)
      "Helper function to print highlighted text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-markups-as-org-text thispdf nil level ))))
        (princ output))
      )

      (defun cpm/pdf-summary-extract (sources)
      "Helper function to print underlined text from a list of pdf's, with one org header per pdf, 
      and links back to page of highlight."
      (let (
            (output ""))
        (dolist (thispdf sources)
          (setq output (concat output (pdf-annot-summary-as-org-text thispdf nil level ))))
        (princ output))
      )

      ;; this is stolen from https://github.com/pinguim06/pdf-tools/commit/22629c746878f4e554d4e530306f3433d594a654
      (defun pdf-annot-edges-to-region (edges)
      "Attempt to get 4-entry region \(LEFT TOP RIGHT BOTTOM\) from several edges.
      We need this to import annotations and to get marked-up text, because annotations
      are referenced by its edges, but functions for these tasks need region."

      (let ((left0 (nth 0 (car edges)))
            (top0 (nth 1 (car edges)))
            (bottom0 (nth 3 (car edges)))
            (top1 (nth 1 (car (last edges))))
            (right1 (nth 2 (car (last edges))))
            (bottom1 (nth 3 (car (last edges))))
            (n (safe-length edges)))
        ;; we try to guess the line height to move
        ;; the region away from the boundary and
        ;; avoid double lines
        (list left0
              (+ top0 (/ (- bottom0 top0) 2))
              right1
              (- bottom1 (/ (- bottom1 top1) 2 )))))

      (defun pdf-annot-markups-as-org-text (pdfpath &optional title level)
      "Acquire highligh annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Quotes From " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
            (if (eq 'highlight (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

            (if (eq 'text (assoc-default 'type annot))
                (let* ((page (assoc-default 'page annot))
                      ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                      (real-edges (pdf-annot-edges-to-region
                                    (pdf-annot-get annot 'markup-edges)))
                      (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                      (height (nth 1 real-edges)) ;; distance down the page
                      ;; use pdfview link directly to page number
                      (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                        "++" (number-to-string height) "][" title  "]]" )))
                  (setq outputstring (concat outputstring text " ("
                                            linktext ", " (number-to-string page) ")\n\n"))
                  ))

              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of highlight
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )

      (defun pdf-annot-summary-as-org-text (pdfpath &optional title level)
      "Acquire underlined annotations as text, and return as org-heading"

      (interactive "fPath to PDF: ")  
      (let* ((outputstring "") ;; the text to be returned
              (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
              (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
              (levelstring (make-string level ?*)) ;; set headline to proper level
              (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                            'pdf-annot-compare-annotations)))
        ;; create the header
        (setq outputstring (concat levelstring " Summary from " title "\n\n")) ;; create heading

        ;; extract text
        (mapc
          (lambda (annot) ;; traverse all annotations
              (if (eq 'underline (assoc-default 'type annot))
                  (let* ((page (assoc-default 'page annot))
                        ;; use pdf-annot-edges-to-region to get correct boundaries of annotation
                        (real-edges (pdf-annot-edges-to-region
                                      (pdf-annot-get annot 'markup-edges)))
                        (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                                  (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath))))

                        (height (nth 1 real-edges)) ;; distance down the page
                        ;; use pdfview link directly to page number
                        (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                          "++" (number-to-string height) "][" title  "]]" )))
                    (setq outputstring (concat outputstring text " ("
                                              linktext ", " (number-to-string page) ")\n\n"))
                    ))
                  )
          annots)
        outputstring ;; return the header
        )
      )


      ))

  (use-package org-pdfview
    :defer t
    :ensure t)

  (use-package pdf-tools-org 
    :defer t
    :commands (pdf-tools-org-export-to-org pdf-tools-org-import-from-org)
    :init
    (add-to-list 'load-path "/Users/Roambot/.emacs.d/pdf-tools-org/"))

#+END_SRC
** Org-ref
I mostly don't use this in favor of helm-bibtex
#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t
  :defer t
  :disabled t
  :after org
  :init
  (setq reftex-default-bibliography '("~/Dropbox/Work/master.bib"))
  (setq org-ref-bibliography-notes "~/Dropbox/Notes/ResearchNotes/"
        org-ref-default-bibliography '("~/Dropbox/Work/master.bib")
        org-ref-pdf-directory "~/Dropbox/Work/MasterLib/")

  ;; helm-bibtex
  (setq bibtex-completion-pdf-field "File")
  (setq helm-bibtex-bibliography "~/Dropbox/Work/master.bib")
  (setq helm-bibtex-library-path "~/Dropbox/Work/MasterLib/")
  (setq bibtex-completion-notes-path "/Users/Roambot/Dropbox/Notes/ResearchNotes/")

  (setq helm-bibtex-pdf-open-function
        (lambda (fpath)
          (start-process "open" "*open*" "open" fpath)))

  (setq helm-bibtex-notes-path "~/Dropbox/Notes/ResearchNotes/")
)
#+END_SRC

** Devonthink
#+BEGIN_SRC emacs-lisp
;;; org-devonthink.el - Support for links to dtp messages by their UUID

;; version 1.1, by John Wiegley <johnw@gnu.org>

(with-eval-after-load "org"

(org-add-link-type "x-devonthink-item" 'org-dtp-open)

(defun org-dtp-open (record-location)
  "Visit the dtp message with the given Message-ID."
  (shell-command (concat "open x-devonthink-item:" record-location)))

(defun org-get-dtp-link (&optional given-name)
  (interactive)
  (let ((name (or given-name
                  (substring (do-applescript (format "
	tell application \"DEVONthink Pro\"
		get name of content record
	end tell")) 1 -1)))
	(location (substring (do-applescript (format "
	tell application \"DEVONthink Pro\"
		get uuid of content record
	end tell")) 1 -1)))
    (org-make-link-string
     (concat "x-devonthink-item://" location) name)))

(defun org-insert-dtp-link ()
  (interactive)
  (let (name)
    (when (region-active-p)
      (setq name (buffer-substring-no-properties (region-beginning)
                                                 (region-end)))
      (delete-region (region-beginning) (region-end)))
    (insert (org-get-dtp-link name))))

(defun org-dtp-store-link ()
  "Store a link to an dtp e-mail message by Message-ID."
  (let ((link-name
	 (with-temp-buffer
	   (clipboard-yank)
	   (buffer-string))))
    (org-store-link-props
     :type "x-devonthink-item"
     :link (cons (concat "x-devonthink-item://" link-name)
		 (concat "x-devonthink-item://" link-name))
     :description (file-name-nondirectory link-name))))
)


;;; org-devonthink.el ends here
#+END_SRC
* Modeline
** Spaceline
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :init 
  (progn 
  (setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
  (setq-default powerline-default-separator 'slant) 
  (setq spaceline-separator-dir-left '(right . right))
  (setq spaceline-separator-dir-right '(right . right))
  ;; fancy git icon for the modeline
  (defadvice vc-mode-line (after strip-backend () activate)
    (when (stringp vc-mode)
      (let ((gitlogo (replace-regexp-in-string "^ Git." ":" vc-mode)))
            (setq vc-mode gitlogo)))))
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme)
  (setq spaceline-buffer-encoding-abbrev-p nil
        spaceline-line-column-p nil
        spaceline-buffer-id-p nil
        spaceline-minor-modes-separator nil))
 
        ;; size of modeline
        (setq powerline-height 21)
        (powerline-reset)
;; don't use srgb & get proper powerline faces
(setq ns-use-srgb-colorspace t)
#+END_SRC

#+RESULTS:

** Fancy Battery
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :defer t
    :init (fancy-battery-mode))
#+END_SRC
 
** Display Time
#+begin_src emacs-lisp :tangle yes
  (setq display-time-format "%a %b %d | %H:%M |")
  (display-time-mode)
#+end_src

#+RESULTS:
: t

* Shell
** Eshell
Emacs own shell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :commands eshell
  :defer t
  :config
  (bind-key "C-x e" 'eshell)
  (setq
   eshell-buffer-shorthand t
   eshell-cmpl-ignore-case t
   eshell-cmpl-cycle-completions nil
   eshell-history-size 10000
   eshell-hist-ignoredups t
   eshell-error-if-no-glob t
   eshell-glob-case-insensitive t
   eshell-scroll-to-bottom-on-input 'all
   eshell-aliases-file (concat user-emacs-directory "eshell/alias")
))
#+END_SRC
** Multi-term
When one shell isn't enough
#+BEGIN_SRC emacs-lisp
(use-package multi-term
    :defer t
    :ensure t
    :config
    (bind-key "C-x m" 'multi-term)
    (setq multi-term-program "/usr/local/bin/zsh")
    (add-hook 'term-mode-hook
            (lambda ()
                (setq term-buffer-maximum-size 10000))))
#+END_SRC
** Sane term
Sane settings for ansi-term
#+BEGIN_SRC emacs-lisp
  (use-package sane-term
    :ensure t
    :defer t
    ;; :commands (sane-term sane-term-create)
    :config
    (evil-leader/set-key "as" 'sane-term)
    ;; shell to use for sane-term
    (setq sane-term-shell-command "/usr/local/bin/zsh")
    ;; sane-term will create first term if none exist
    (setq sane-term-initial-create t)
    ;; `C-d' or `exit' will kill the term buffer.
    (setq sane-term-kill-on-exit t)
    ;; After killing a term buffer, not cycle to another.
    (setq sane-term-next-on-kill nil))
#+END_SRC
** Shell Pop
A popup shell
#+begin_src emacs-lisp :tangle yes
     (use-package shell-pop
        :defer t
        :ensure t
        :init
        (evil-leader/set-key "'" 'shell-pop)
        :config
         (defun ansi-term-handle-close ()
          "Close current term buffer when `exit' from term buffer."
          (when (ignore-errors (get-buffer-process (current-buffer)))
            (set-process-sentinel (get-buffer-process (current-buffer))
                                  (lambda (proc change)
                                    (when (string-match "\\(finished\\|exited\\)" change)
                                      (kill-buffer (process-buffer proc))
                                      (delete-window))))))
        (add-hook 'term-mode-hook 'ansi-term-handle-close)
        (add-hook 'term-mode-hook (lambda () (linum-mode -1) (centered-window-mode 0)))
        )
#+end_src

** Shell settings
Other useful shell settings  
#+begin_src emacs-lisp
    ;; basic settings
    (setq explicit-shell-file-name "/usr/local/bin/zsh")
    
    ;; kill ansi-buffer on exit
    (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
      (if (memq (process-status proc) '(signal exit))
          (let ((buffer (process-buffer proc)))
            ad-do-it
            (kill-buffer buffer))
        ad-do-it))
    (ad-activate 'term-sentinel)

    ;; clickable links & no highlight of line
    (defun my-term-hook ()
      (goto-address-mode) (global-hl-line-mode 0))
    (add-hook 'term-mode-hook 'my-term-hook)

  ;; paste and navigation
  (defun term-send-tab ()
      "Send tab in term mode."
      (interactive)
      (term-send-raw-string "\t"))
    ;; hack to fix pasting issue, the paste micro-state won't
    ;; work in term
    (evil-define-key 'normal term-raw-map "p" 'term-paste)
    (evil-define-key 'insert term-raw-map (kbd "C-c C-d") 'term-send-eof)
    (evil-define-key 'insert term-raw-map (kbd "C-c C-z") 'term-stop-subjob)
    (evil-define-key 'insert term-raw-map (kbd "<tab>") 'term-send-tab)

    (evil-define-key 'insert term-raw-map
      (kbd "s-v") 'term-paste
      (kbd "C-k") 'term-send-up
      (kbd "C-j") 'term-send-down)
    (evil-define-key 'normal term-raw-map
      (kbd "C-k") 'term-send-up
      (kbd "C-j") 'term-send-down)

#+end_src
** Shell Script Mode
Open zsh files in shell-script mode
#+BEGIN_SRC emacs-lisp
(use-package sh-script
    :defer t
    :init
    (progn
      ;; Use sh-mode when opening `.zsh' files, and when opening Prezto runcoms.
      (dolist (pattern '("\\.zsh\\'"
                         "zlogin\\'"
                         "zlogout\\'"
                         "zpreztorc\\'"
                         "zprofile\\'"
                         "zshenv\\'"
                         "zshrc\\'"))
        (add-to-list 'auto-mode-alist (cons pattern 'sh-mode)))

      (defun spacemacs//setup-shell ()
        (when (and buffer-file-name
                   (string-match-p "\\.zsh\\'" buffer-file-name))
          (sh-set-shell "zsh")))
      (add-hook 'sh-mode-hook 'spacemacs//setup-shell)))
#+END_SRC

** Compilation buffer

Whenever I run ~compile~, the buffer stays even after a successful compilation. Let's make it close automatically if the compilation is successful.

#+BEGIN_SRC emacs-lisp
(setq compilation-finish-functions
      (lambda (buf str)
        (if (null (string-match ".*exited abnormally.*" str))
            ;;no errors, make the compilation window go away in a few seconds
            (progn
              (run-at-time "0.4 sec" nil
                           (lambda ()
                             (select-window (get-buffer-window (get-buffer-create "*compilation*")))
                             (switch-to-buffer nil)))
              (message "No Compilation Errors!")))))
#+END_SRC
* Version Control
Magit is a great interface for git projects. It's much more pleasant to use than
the standard git interface on the command line. I've set up some easy
keybindings to access magit and related packages.

** Evil Magit
evil bindings for magit
#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :ensure t
    :after magit
    :defer t)
  (use-package magit
    :ensure t
    :defer t
    :commands
   (magit-blame-mode
    magit-commit
    magit-diff
    magit-log
    magit-status)
    :init
    (with-eval-after-load 'evil-leader
    (evil-leader/set-key
      (kbd "gb") #'magit-blame
      (kbd "gc") #'magit-commit
      (kbd "gd") #'magit-diff
      (kbd "gl") #'magit-log
      (kbd "gr") #'magit-reflog
      (kbd "gs") #'magit-status))
    (with-eval-after-load 'which-key
    (which-key-declare-prefixes
    "<SPC>g" "Git"))
    :config
    (require 'evil-magit)
    (setq vc-follow-symlinks t)
    (setq-default git-magit-status-fullscreen nil)
    (setq magit-diff-refine-hunk 'all)
    (global-git-commit-mode t) ; use spacemacs as editor for git commits
    (add-hook 'magit-diff-mode-hook (lambda () (setq cursor-type nil)))
    (add-hook 'magit-log-mode-hook (lambda () (setq cursor-type nil)))
    (add-hook 'magit-log-select-mode-hook (lambda () (setq cursor-type nil)))
    (add-hook 'magit-refs-mode-hook (lambda () (setq cursor-type nil)))
    (add-hook 'magit-revision-mode-hook (lambda () (setq cursor-type nil)))
    (add-hook 'magit-status-mode-hook #'hl-line-mode)
    (add-hook 'magit-status-mode-hook (lambda () (setq cursor-type nil)))
    (add-hook 'with-editor-mode-hook 'evil-insert-state)
    (bind-keys
    :map magit-status-mode-map
    ("<C-tab>"   . nil)
    ("<backtab>" . magit-section-cycle))
    (setq magit-push-always-verify nil)
  )
#+END_SRC

** Git timemachine
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine            ; Go back in Git time
  :ensure t
  :defer t
)
#+END_SRC
 
** Git gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter+
      :ensure t
      :defer t
      :init
      (progn
        (add-hook 'markdown-mode-hook #'git-gutter+-mode)
        (add-hook 'prog-mode-hook #'git-gutter+-mode)))
        ;; ;; If you enable global minor mode
        ;;   (add-hook 'magit-pre-refresh-hook 'git-gutter+-refresh)
          ;; (global-git-gutter+-mode t)))
#+END_SRC
 
** Fringe
#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe+
  :ensure t
  :defer t
  :commands git-gutter+-mode
  :init
    (progn
      (when (display-graphic-p)
        (with-eval-after-load 'git-gutter+
          (require 'git-gutter-fringe+)))
      (setq git-gutter-fr+-side 'right-fringe))
  :config
    (progn
      ;; custom graphics that works nice with half-width fringes
      (fringe-helper-define 'git-gutter-fr+-added nil
        "..X...."
        "..X...."
        "XXXXX.."
        "..X...."
        "..X...."
        )
      (fringe-helper-define 'git-gutter-fr+-deleted nil
        "......."
        "......."
        "XXXXX.."
        "......."
        "......."
        )
      (fringe-helper-define 'git-gutter-fr+-modified nil
        "..X...."
        ".XXX..."
        "XX.XX.."
        ".XXX..."
        "..X...."
        )))
#+END_SRC
* Navigation
** Projectile
#+BEGIN_SRC emacs-lisp
 (use-package projectile
    :ensure t
    :defer t
    :commands (projectile-ack
               projectile-ag
               projectile-compile-project
               projectile-dired
               projectile-find-dir
               projectile-find-file
               projectile-find-tag
               projectile-find-test-file
               projectile-grep
               projectile-invalidate-cache
               projectile-kill-buffers
               projectile-multi-occur
               projectile-project-p
               projectile-project-root
               projectile-recentf
               projectile-regenerate-tags
               projectile-replace
               projectile-run-async-shell-command-in-root
               projectile-run-shell-command-in-root
               projectile-switch-project
               projectile-switch-to-buffer
               projectile-vc)
    :config
    (progn
      (projectile-global-mode)))
#+END_SRC
** Helm
A completion framework and much more. For a complete overview see [[http://tuhdo.github.io/helm-intro.html][the tutorial]].
#+begin_src emacs-lisp :tangle yes
  (use-package helm
    :ensure t
    :diminish (helm-mode . "")
    :defer 2
    :config
    (progn
      (setq helm-M-x-fuzzy-match t  ;; Use fuzzy match in helm
            helm-buffers-fuzzy-matching t
            helm-recentf-fuzzy-match t
            helm-prevent-escaping-from-minibuffer t
            helm-bookmark-show-location t
            helm-find-files-sort-directories t
            helm-display-header-line nil
            helm-always-two-windows t                       
            helm-split-window-in-side-p t
            helm-echo-input-in-header-line t
            helm-locate-fuzzy-match nil
            helm-locate-command "mdfind -interpret -name %s %s")
      (bind-key* "C-x r b" 'helm-filtered-bookmarks)
      (bind-key* "M-x" 'helm-M-x)
      (bind-key* "C-x C-f" 'helm-find-files)
      ;;; helm vim-bindings in buffer ;;
      (define-key helm-map (kbd "C-j") 'helm-next-line)
      (define-key helm-map (kbd "C-k") 'helm-previous-line)
      (define-key helm-map (kbd "C-h") 'helm-next-source)
      (define-key helm-map (kbd "C-S-h") 'describe-key)
      (define-key helm-map (kbd "C-l") (kbd "RET"))

      (setq helm-boring-buffer-regexp-list '("\\*SPEEDBAR" "\\*magit" "\\*Sunshine" "\\*Help" "\\*Shell Command Output" "\\*Flycheck error message" "\\*Compile-Log" "\\` " "\\*helm" "\\*helm-mode" "\\*Echo Area" "\\*Minibuf"))
      (helm-autoresize-mode 1)
      (setq helm-autoresize-max-height 40)
      (setq helm-autoresize-min-height 35)

      ;; enter text at eye level
      (defun helm-hide-minibuffer-maybe ()
        (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                              `(:background ,bg-color :foreground ,bg-color)))
                              (setq-local cursor-type nil))))

      (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
      (helm-mode 1)))
#+end_src
** Helm packages
*** Helm ag
#+begin_src emacs-lisp :tangle yes
(use-package helm-ag :ensure t :defer t)
#+end_src
*** Helm descbinds
#+begin_src emacs-lisp :tangle yes
      (use-package helm-descbinds 
        :ensure t 
        :defer t
        :config
        (setq helm-descbinds-window-style 'split)
        (add-hook 'helm-mode-hook 'helm-descbinds-mode)
        (evil-leader/set-key "?" 'helm-descbinds))
#+end_src
*** Helm git list
#+begin_src emacs-lisp :tangle yes
(use-package helm-ls-git :ensure t :defer t)
#+end_src
*** Helm swoop
Search on steroids
#+begin_src emacs-lisp :tangle yes
  (use-package helm-swoop
    :defer t
    :ensure t
    :config
    ;; If this value is t, split window inside the current window
    (setq helm-swoop-split-with-multiple-windows t)
  )
#+end_src
*** Helm flyspell
Use helm with flyspell
#+begin_src emacs-lisp :tangle yes
  (use-package helm-flyspell
    :defer t
    :ensure t
    :commands helm-flyspell-correct
  )
#+end_src

*** Helm recent directories
Recent directories
#+begin_src emacs-lisp :tangle yes
  (use-package helm-dired-recent-dirs
    :defer t
    :ensure t)
#+end_src
*** Helm files
#+begin_src emacs-lisp :tangle yes
  (use-package helm-files
    :defer t
    :config
    (setq helm-ff-skip-boring-files t)
    (setq helm-ff-file-name-history-use-recentf t)
    (setq helm-boring-file-regexp-list
    '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "~$"
      "\\.so$" "\\.a$" "\\.elc$" "\\.fas$" "\\.fasl$" "\\.pyc$" "\\.pyo$")))
#+end_src

*** Helm-projectile
#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  :defer t
  :commands (helm-projectile-switch-to-buffer
             helm-projectile-find-dir
             helm-projectile-dired-find-dir
             helm-projectile-recentf
             helm-projectile-find-file
             helm-projectile-grep
             helm-projectile
             helm-projectile-switch-project)
  :init
    (progn
      (setq projectile-switch-project-action 'helm-projectile)))
#+END_SRC
** Speedbar
A file tree and outliner
#+BEGIN_SRC emacs-lisp
    (use-package sr-speedbar
      :ensure t
      :defer t
      :commands sb-expand-current-file
      :config
        (progn 
          (setq sr-speedbar-width 60)
          (setq sr-speedbar-max-width 60)
          (setq sr-speedbar-right-side nil)
          ;; Auto expand
          (defun sb-expand-current-file ()
          "Expand current file in speedbar buffer"
          (interactive)
          (setq current-file (buffer-file-name))
          (sr-speedbar-toggle)
          (speedbar-find-selected-file current-file)
          (speedbar-toggle-line-expansion))
          ;; Switch to window
          (defun speedbar-edit-line-and-switch-to-window ()
          (interactive)
          (speedbar-edit-line)
          (other-window 1))

          ;; other settings
          (setq speedbar-hide-button-brackets-flag t
              speedbar-show-unknown-files t
              speedbar-directory-button-trim-method 'trim
              speedbar-use-images nil
              speedbar-indentation-width 2
              speedbar-use-imenu-flag t
              speedbar-tag-hierarchy-method nil  ;; No grouping
              speedbar-file-unshown-regexp "flycheck-.*"
              speedbar-directory-unshown-regexp "^\\(CVS\\|RCS\\|SCCS\\|\\.\\.*$\\)\\'"    
              speedbar-smart-directory-expand-flag t)
          ;; Add markdown support
          (speedbar-add-supported-extension ".md")
          (speedbar-add-supported-extension ".org")
          ;; More familiar keymap settings.
          (add-hook 'speedbar-reconfigure-keymaps-hook
                  '(lambda ()
                      (define-key speedbar-mode-map [tab] 'speedbar-toggle-line-expansion)
                      (define-key speedbar-mode-map [return] 'speedbar-edit-line-and-switch-to-window)))))

#+END_SRC
** Code documentation

[[https://kapeli.com/dash][Dash]] is a nice little app that stores documents offline for reference. Let's [[https://github.com/stanaka/dash-at-point][bring that to Emacs]].

#+BEGIN_SRC emacs-lisp
(use-package dash-at-point
  :ensure t)
#+END_SRC

** Back button

The one thing I missed from Vim when I switched to Emacs was Vim's jump list. [[https://www.emacswiki.org/emacs/BackButton][Back button mode]] provides a similar navigation in Emacs where you navigate to the points where you made changes previously. Comes in really handy at times.

#+BEGIN_SRC emacs-lisp
(use-package back-button
  :ensure t
  :diminish back-button-mode
  :defer 2
  :init
  (setq back-button-show-toolbar-buttons nil)
  :config
  (back-button-mode 1))
#+END_SRC
* Distraction Free Mode
#+BEGIN_SRC emacs-lisp
(use-package centered-window-mode
  :defer t
  :ensure t
  :diminish centered-window-mode
  :config
  (setq cwm-centered-window-width 90))
  (defun distraction-free ()
  "distraction free writing"
    (interactive)
    (centered-window-mode) (git-gutter+-mode) (linum-mode 0) (toggle-frame-fullscreen) (visual-line-mode))
#+END_SRC
 
* Notes
#+BEGIN_SRC emacs-lisp
(use-package deft
  :defer t
  :ensure t
  :init
  (progn
    (setq deft-extensions '("org" "md" "txt")
          deft-directory "~/projects/notebook/content/org_notes"
          deft-text-mode 'org-mode
          deft-use-filter-string-for-filename t ;; use filter string as filename
          deft-org-mode-title-prefix t ;; add #+TITLE prefix
          deft-recursive t  ;; search recursively in folders
          deft-use-filename-as-title t)

    (defun cpm/deft ()
      "Helper to call deft and then fix things so that it is nice and works"
      (interactive)
      (require 'org)
      (deft)
      ;; Hungry delete wrecks deft's DEL override
      (when (fboundp 'hungry-delete-mode)
        (hungry-delete-mode -1))
      ;; When opening it you always want to filter right away
      (evil-insert-state nil)))
  :config
  (progn
    (evil-define-key 'normal deft-mode-map
      "d" 'deft-delete-file
      "i" 'deft-toggle-incremental-search
      "n" 'deft-new-file
      "r" 'deft-rename-file)))
      
;; Make sure titles have no spaces: from [[http://pragmaticemacs.com/category/deft/][pragmaticemacs]]
;;advise deft-new-file-named to replace spaces in file names with -
(defun bjm-deft-strip-spaces (args)
  "Replace spaces with - in the string contained in the first element of the list args. Used to advise deft's file naming function."
  (list (replace-regexp-in-string " " "-" (car args)))
  )
(advice-add 'deft-new-file-named :filter-args #'bjm-deft-strip-spaces)
#+END_SRC

* Other packages
** Ace-Jump-Mode
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :ensure t
  :defer t
  :init 
  (evil-leader/set-key
     "j" 'ace-jump-mode))
#+END_SRC
 
** Ag
#+BEGIN_SRC emacs-lisp
  (use-package ag
  :ensure t
  :defer t
  :config
  (progn

    (defun ag/jump-to-result-if-only-one-match ()
      "Jump to the first ag result if that ag search came up with just one match."
      (let (only-one-match)
        (when (member "--stats" ag-arguments)
          (save-excursion
            (goto-char (point-min))
            (setq only-one-match (re-search-forward "^1 matches\\s-*$" nil :noerror)))
          (when only-one-match
            (next-error)
            (kill-buffer (current-buffer))
            (message (concat "ag: Jumping to the only found match and "
                             "killing the *ag* buffer."))))))
    (add-hook 'ag-search-finished-hook #'ag/jump-to-result-if-only-one-match)  
    
    ;; Set default ag arguments
    ;; It looks like the ~/.agignore is used when launching ag from emacs too.
    ;; So the ignores from ~/.agignore don't have to be set here again.

    (setq helm-ag-base-command "/usr/local/bin/ag --ignore-case")
    (setq ag-highlight-search t)
    ;; By default, ag.el will open results in a different window in the frame, so
    ;; the results buffer is still visible. You can override this so the results
    ;; buffer is hidden and the selected result is shown in its place:
    (setq ag-reuse-window nil)
    ;; reuse the same *ag* buffer for all your searches
    (setq ag-reuse-buffers t)
    ;; ;; To save buffer automatically when `wgrep-finish-edit'
    ;; (setq wgrep-auto-save-buffer t)

    (with-eval-after-load 'projectile
      ;; Override the default function to use the projectile function instead
      (defun ag/project-root (file-path)
        (let ((proj-name (projectile-project-root)))
          (if proj-name
              proj-name ; return `projectile-project-root' if non-nil
            ;; Else condition is same as the `ag/project-root' definition
            ;; from ag.el
            (if ag-project-root-function
                (funcall ag-project-root-function file-path)
              (or (ag/longest-string
                   (vc-git-root file-path)
                   (vc-svn-root file-path)
                   (vc-hg-root file-path))
                  file-path))))))))

#+END_SRC
 
** Autopair
#+BEGIN_SRC emacs-lisp
(use-package electric-pair-mode
  :defer t
  :init 
  (electric-pair-mode 1))
#+END_SRC
** Autorevert
Auto-revert buffers of changed files
#+BEGIN_SRC emacs-lisp
  (use-package autorevert                 
    :defer 2
    :init
    (global-auto-revert-mode)
    :config
    (progn 
      (setq auto-revert-verbose nil ; Shut up, please!
            ;; Revert Dired buffers, too
            global-auto-revert-non-file-buffers t)))
#+END_SRC
 
** Centered Cursor Mode
#+BEGIN_SRC emacs-lisp
  (use-package centered-cursor-mode
    :ensure t
    :defer t
    :diminish centered-cursor-mode
    ;; :commands (centered-cursor-mode
    ;;            global-centered-cursor-mode)
    :config
    (progn
      (setq ccm-recenter-at-end-of-file t
            ccm-ignored-commands '(mouse-drag-region
                                   mouse-set-point
                                   widget-button-click
                                   scroll-bar-toolkit-scroll
                                   evil-mouse-drag-region))))
#+END_SRC

** Diminish
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t)
#+END_SRC
*** Diminish minor modes
#+BEGIN_SRC emacs-lisp
  (diminish 'visual-line-mode)
  (eval-after-load "flyspell" '(diminish 'flyspell-mode "Ⓢ")) 
  (eval-after-load "org-indent" '(diminish 'org-indent-mode))
  (eval-after-load "simple" '(diminish 'auto-fill-function "Ⓕ")) 
  (eval-after-load "pandoc-mode" '(diminish 'pandoc-mode "Ⓟ"))
  (eval-after-load "git-gutter+" '(diminish 'git-gutter+-mode))
  (eval-after-load "company" '(diminish 'company-mode "Ⓒ"))
  (eval-after-load "cm-mode" '(diminish 'cm-mode "ⓒ"))
  (eval-after-load "reftex" '(diminish 'reftex-mode "ⓡ"))
  ;; (eval-after-load "autorevert" '(diminish 'auto-revert-mode))
  (eval-after-load "simple" '(diminish 'auto-revert-mode "Ⓡ"))
  (eval-after-load "aggressive-indent" '(diminish 'aggressive-indent-mode "Ⓘ"))
  (eval-after-load "auto-indent-mode" '(diminish 'auto-indent-mode "ⓘ"))
  (eval-after-load "smartparens" '(diminish 'smartparens-mode "ⓟ"))
  ;; (eval-after-load "undo-tree" '(diminish 'undo-tree-mode "Ⓤ"))
  (eval-after-load "undo-tree" '(diminish 'undo-tree-mode ""))
  (eval-after-load "projectile" '(diminish 'projectile-mode ""))
  #+END_SRC

#+RESULTS:
|   |

** Doc View Mode
#+begin_src emacs-lisp :tangle yes
(use-package doc-view
    :defer t
    :init
    (evil-define-key 'normal doc-view-mode-map
      "/"  'spacemacs/doc-view-search-new-query
      "?"  'spacemacs/doc-view-search-new-query-backward
      "gg" 'doc-view-first-page
      "G"  'doc-view-last-page
      "gt" 'doc-view-goto-page
      "h"  'doc-view-previous-page
      "j"  'doc-view-next-line-or-next-page
      "k"  'doc-view-previous-line-or-previous-page
      "K"  'doc-view-kill-proc-and-buffer
      "l"  'doc-view-next-page
      "n"  'doc-view-search
      "N"  'doc-view-search-backward
      (kbd "C-d") 'doc-view-scroll-up-or-next-page
      (kbd "C-k") 'doc-view-kill-proc
      (kbd "C-u") 'doc-view-scroll-down-or-previous-page)
    :config
    (progn
      (defun spacemacs/doc-view-search-new-query ()
        "Initiate a new query."
        (interactive)
        (doc-view-search 'newquery))

      (defun spacemacs/doc-view-search-new-query-backward ()
        "Initiate a new query."
        (interactive)
        (doc-view-search 'newquery t))

      ;; fixed a weird issue where toggling display does not
      ;; swtich to text mode
      (defadvice doc-view-toggle-display
          (around spacemacs/doc-view-toggle-display activate)
        (if (eq major-mode 'doc-view-mode)
            (progn
              ad-do-it
              (text-mode)
              (doc-view-minor-mode))
          ad-do-it))
          
(defcustom doc-view-autofit-timer-start 1.0
"Initial value (seconds) for the timer that delays the fitting when
`doc-view-autofit-fit' is called (Which is when a window
configuration change occurs and a document needs to be fitted)."
:type 'number
:group 'doc-view)

(defcustom doc-view-autofit-timer-inc 0.02
"Value to increase (seconds) the timer (see `doc-view-autofit-timer-start')
by, if there is another window configuration change occuring, before
it runs out."
:type 'number
:group 'doc-view)

(defcustom doc-view-autofit-default-fit 'width
"The fitting type initially used when mode is enabled.
Valid values are: width, height, page."
:type 'symbol
:group 'doc-view)

(defvar doc-view-autofit-mode-map
(let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c W") 'doc-view-autofit-width)
    (define-key map (kbd "C-c H") 'doc-view-autofit-height)
    (define-key map (kbd "C-c P") 'doc-view-autofit-page)
    map)
"Keymap used by `doc-view-autofit-mode'.")

(defun doc-view-autofit-set (type)
"Set autofitting to TYPE for current buffer."
(when doc-view-autofit-mode
    (setq doc-view-autofit-type type)
    (doc-view-autofit-fit)))

(defun doc-view-autofit-width ()
"Set autofitting to width for current buffer."
(interactive) (doc-view-autofit-set 'width))

(defun doc-view-autofit-height ()
"Set autofitting to height for current buffer."
(interactive) (doc-view-autofit-set 'height))

(defun doc-view-autofit-page ()
"Set autofitting to page for current buffer."
(interactive) (doc-view-autofit-set 'page))

(defun doc-view-autofit-fit ()
"Fits the document in the selected window's buffer
delayed with a timer, so multiple calls in succession
don't cause as much overhead."
(lexical-let
    ((window (selected-window)))
    (if (equal doc-view-autofit-timer nil)
        (setq doc-view-autofit-timer
            (run-with-timer
            doc-view-autofit-timer-start nil
            (lambda ()
                (if (window-live-p window)
                    (save-selected-window
                    (select-window window)
                    (cancel-timer doc-view-autofit-timer)
                    (setq doc-view-autofit-timer nil)
                    (cond
                        ((equal 'width doc-view-autofit-type)
                        (doc-view-fit-width-to-window))
                        ((equal 'height doc-view-autofit-type)
                        (doc-view-fit-height-to-window))
                        ((equal 'page doc-view-autofit-type)
                        (doc-view-fit-page-to-window))))))))
    (timer-inc-time doc-view-autofit-timer doc-view-autofit-timer-inc))))

(define-minor-mode doc-view-autofit-mode
"Minor mode for automatic (timer based) fitting in DocView."
:lighter " AFit" :keymap doc-view-autofit-mode-map :group 'doc-view
(when doc-view-autofit-mode
    (set (make-local-variable 'doc-view-autofit-type)
        doc-view-autofit-default-fit)
    (set (make-local-variable 'doc-view-autofit-timer) nil)
    (add-hook 'window-configuration-change-hook
            'doc-view-autofit-fit nil t)
    (doc-view-autofit-fit))
(when (not doc-view-autofit-mode)
    (remove-hook 'window-configuration-change-hook
                'doc-view-autofit-fit t)
    (when doc-view-autofit-timer
    (cancel-timer doc-view-autofit-timer)
    (setq doc-view-autofit-timer nil))
    (setq doc-view-autofit-type nil)))

(add-hook 'doc-view-mode-hook 'doc-view-autofit-mode)
;; reload when file changes
(add-hook 'doc-view-mode-hook 'auto-revert-mode)
;; continuous scroll mode
(setq doc-view-continuous t)
))
#+end_src
** Fringe helper
#+BEGIN_SRC emacs-lisp
(use-package fringe-helper
  :defer t
  :ensure t)
#+END_SRC
 
** Iedit
[[https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer][Iedit-mode]] is the bomb. Quick, fast edits of every symbol selected. Although [[*Multiple cursors][multiple cursors]] has some more features, this is the best choice for quick renaming of variables/words.

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :ensure t
  :defer t
)
#+END_SRC
 
** Info+
#+BEGIN_SRC emacs-lisp
(use-package info+
  :ensure t
  :defer t)
#+END_SRC
 
** Highlight numbers
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :ensure t
  :defer t 
  :init
  (add-hook 'prog-mode-hook #'highlight-numbers-mode))
#+END_SRC
 
** Highlight TODOs
highlight TODO statements in comments 
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :ensure t
  :defer t)
#+END_SRC
 
** Paradox
#+BEGIN_SRC emacs-lisp
(use-package paradox
  :ensure t
  :defer t
  :config
  (setq paradox-execute-asynchronously t
        paradox-github-token t))
#+END_SRC

** Persp-mode
#+begin_src emacs-lisp :tangle yes
  (use-package persp-mode
    :ensure t
    :diminish persp-mode
    :defer t)
    ;; :config (setq persp-show-modestring t))
#+end_src
** Rainbow Delimiters
   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters 
      :ensure t
      :defer t
      :init
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC
** Rainbow identifiers
#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :ensure t
  :defer t
  :init
  (add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
#+END_SRC
** Rainbow mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :defer t
  :commands rainbow-mode
)
#+END_SRC 
** Ranger
Better dired navigation using ranger-like settings
#+BEGIN_SRC emacs-lisp
  (use-package ranger
  :ensure t
  :defer t
  :init
  (progn
    (setq ranger-override-dired t)
    ;; set up image-dired to allow picture resize
    (setq image-dired-dir (concat user-emacs-directory "image-dir"))
    (unless (file-directory-p image-dired-dir)
    (make-directory image-dired-dir)))
  :config
  (progn
    (define-key ranger-mode-map (kbd "-") 'ranger-up-directory)
    (setq ranger-cleanup-eagerly t
          ranger-dont-show-binary t
          ranger-excluded-extensions '("mkv" "iso" "mp4")
          ranger-max-preview-size 25
          ranger-preview-file t
          ranger-show-dotfiles t
          ranger-width-parents 0.25
          ranger-width-preview 0.55 
          ))
  )
#+END_SRC

** Restart emacs
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t
  :defer t
 )
#+END_SRC
 
** Reveal in Finder
#+BEGIN_SRC emacs-lisp
(use-package reveal-in-osx-finder
  :ensure t
  :defer t
   ;;:commands reveal-in-osx-finder
  :init
  (global-set-key (kbd "C-c f") 'reveal-in-osx-finder)
)
#+END_SRC
 
** Saveplace
#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :defer 2
  :init
  (setq-default save-place t)
  :config
  (setq save-place-file "~/.emacs.d/saved-places")
  (setq save-place-forget-unreadable-files nil)
)
#+END_SRC
 
** Smartparenthesis

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :defer t
    :init
      (progn
        (setq sp-show-pair-delay 0.2
        ;; fix paren highlighting in normal mode
        sp-show-pair-from-inside t
        sp-cancel-autoskip-on-backward-movement nil)
        (add-hook 'markdown-mode-hook #'smartparens-mode)
        (add-hook 'org-mode-hook #'smartparens-mode)
        (add-hook 'prog-mode-hook #'smartparens-mode)))
      
  (use-package evil-smartparens
    :ensure t
    :defer t
    :init 
    (add-hook 'smartparens-mode #'evil-smartparens-mode))
#+END_SRC
 
** Sunshine Weather app
#+BEGIN_SRC emacs-lisp
(use-package sunshine
  :ensure t
  :disabled t
  :defer t
  ;;:commands (sunshine-forecast sunshine-quick-forecast)
  :init 
  (progn 
    (evil-leader/set-key 
      "aw" 'sunshine-forecast
      "aW" 'sunshine-quick-forecast
     ))
  :config
  (progn
    (setq sunshine-show-icons t)
    (evil-define-key 'normal sunshine-mode-map
      (kbd "q") 'quit-window
      (kbd "i") 'sunshine-toggle-icons))
    (setq sunshine-location "68503,USA")
)

#+END_SRC
 
** Uniquify
Distinguish buffers with the same name
#+begin_src emacs-lisp :tangle yes
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator "/"
        uniquify-after-kill-buffer-p t
        uniquify-ignore-buffers-re "^\\*"))
#+end_src
** Visual replace

This is the [[https://github.com/benma/visual-regexp.el][good old search and replace]] as opposed to the fancy alternatives such as [[*Interactive edit][iedit]] and [[*Multiple cursors][multiple cursors]]. You search for a word in the buffer/region, type in the replacement and confirm each one by pressing =y= or =n= or just press =!= to apply this to everything.

#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure t
  :commands (vr/query-replace)
  :config
  (use-package visual-regexp-steroids
    :ensure t
    :commands (vr/select-query-replace)))
#+END_SRC

** Weather
#+BEGIN_SRC emacs-lisp
(use-package wttrin
  :ensure t
  :defer t
  :commands (wttrin wttrin-exit)
  :init
  (progn 
    (setq wttrin-default-cities '("Providence" "Lincoln, NE"))
    (evil-leader/set-key 
      "aw" 'wttrin))
)
#+END_SRC
** Which Key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish ""
  :config
  (setq which-key-special-keys nil)
  ;; Set the time delay (in seconds) for the which-key popup to appear.
  (setq which-key-idle-delay .2)
  (which-key-mode))
#+END_SRC
** Window Numbering
Numbered window shortcuts for Emacs
#+BEGIN_SRC emacs-lisp
    (use-package window-numbering
      :ensure t
      :config
      (progn
          (defun window-numbering-install-mode-line (&optional position)
            "Do nothing, the display is handled by the powerline.")
        (setq window-numbering-auto-assign-0-to-minibuffer nil)
        (evil-leader/set-key
          "0" 'select-window-0
          "1" 'select-window-1
          "2" 'select-window-2
          "3" 'select-window-3
          "4" 'select-window-4
          "5" 'select-window-5)
          ;; "6" 'select-window-6
          ;; "7" 'select-window-7
          ;; "8" 'select-window-8
          ;; "9" 'select-window-9)
        (window-numbering-mode 1)))

     (defun spacemacs//window-numbering-assign (windows)
       "Custom number assignment for special buffers."
       (mapc (lambda (w)
               (when (and (boundp 'neo-global--window)
                          (eq w neo-global--window))
                 (window-numbering-assign w 0)))
             windows))
     (add-hook 'window-numbering-before-hook 'spacemacs//window-numbering-assign)
     (add-hook 'neo-after-create-hook '(lambda (w) (window-numbering-update)))

  ; (use-package window-numbering
  ;   :ensure t
  ;   :init (window-numbering-mode))
  ;   :config
  ;   (window-numbering-clear-mode-line)

#+END_SRC
** Windmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :defer t
  :ensure t
  :config
  (progn
    (defun split-window-right-and-focus ()
    "Split the window horizontally and focus the new window."
    (interactive)
    (split-window-right)
    (windmove-right))
    (defun split-window-below-and-focus ()
    "Split the window vertically and focus the new window."
    (interactive)
    (split-window-below)
    (windmove-down))
  )
)
#+END_SRC
** Add some useful libraries

[[https://github.com/jwiegley/emacs-async][async]], [[https://github.com/magnars/s.el][s]], [[https://github.com/magnars/dash.el][dash]], and [[http://elpa.gnu.org/packages/cl-lib.html][cl-lib]] are libraries for asynchronous processing, string manipulation, list manipulation and backward compatibility respectively.

#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :commands (async-start))

(use-package cl-lib
  :ensure t)

(use-package dash
  :ensure t)

(use-package s
  :ensure t)
#+END_SRC
 
* Completion
** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet                
    :ensure t
    :defer t
    :diminish (yas-minor-mode . " Ⓨ")
    :init
    (progn
      (add-hook 'prog-mode-hook #'yas-minor-mode)
      (add-hook 'org-mode-hook #'yas-minor-mode)
      (add-hook 'markdown-mode-hook #'yas-minor-mode)
      ;; Develop in ~/emacs.d/mysnippets, but also
      ;; try out snippets in ~/Downloads/interesting-snippets
      (setq yas-snippet-dirs '("/Users/Roambot/.emacs.d/snippets/"
               "/Users/Roambot/Downloads/interesting-snippets/"))
               
      ;; (add-hook 'term-mode-hook (lambda()
      ;;     (setq yas-dont-activate t)))
      )
     :config 
     (yas-reload-all))

#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
    (use-package company
        :ensure t
        :defer t
        :init
        (progn
          ;; (add-hook 'after-init-hook 'global-company-mode)
          (add-hook 'prog-mode-hook 'company-mode)
          (add-hook 'org-mode-hook 'company-mode)
          (add-hook 'markdown-mode-hook 'company-mode)  
          (setq company-idle-delay 0.2
                company-minimum-prefix-length 2
                company-require-match nil
                company-dabbrev-ignore-case nil
                company-dabbrev-downcase nil))
        :commands (company-mode)
        :config
        (progn
          ;; latex
          (add-to-list 'company-backends #'company-latex-commands)

          ;; key bindings
          (let ((map company-active-map))
            (define-key map (kbd "C-/") 'company-search-candidates)
            (define-key map (kbd "C-M-/") 'company-filter-candidates)
            (define-key map (kbd "C-d") 'company-show-doc-buffer)
            (define-key map (kbd "C-j") 'company-select-next)
            (define-key map (kbd "C-k") 'company-select-previous)
            (define-key map (kbd "C-l") 'company-complete-selection))
          ;; Nicer looking faces
          (custom-set-faces
           '(company-tooltip-common
             ((t (:inherit company-tooltip :weight bold :underline nil))))
           '(company-tooltip-common-selection
             ((t (:inherit company-tooltip-selection :weight bold :underline nil)))))
  ))
#+END_SRC
*** Auc-tex
#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :ensure t
  :defer t
 )
#+END_SRC
*** Company math
#+BEGIN_SRC emacs-lisp
(use-package company-math
  :ensure t
  :defer t
  :init 
    (with-eval-after-load 'company
    ;; Add backends for math characters
    (add-to-list 'company-backends 'company-math-symbols-unicode)
    (add-to-list 'company-backends 'company-math-symbols-latex))
)
#+END_SRC
* Languages
** Elisp
#+BEGIN_SRC emacs-lisp
(use-package ielm
    :defer t
    :init
    (progn
      (dolist (mode '(emacs-lisp-mode lisp-interaction-mode))))
    :config
    (defun ielm-indent-line ()
      (interactive)
      (let ((current-point (point)))
        (save-restriction
          (narrow-to-region (search-backward-regexp "^ELISP>") (goto-char current-point))
          (lisp-indent-line)))))

 (use-package elisp-slime-nav
    :ensure t
    :defer t)

 (use-package eldoc
  :diminish eldoc-mode
  :commands eldoc-mode)

(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (setq show-trailing-whitespace t)
            (show-paren-mode)
            (prettify-symbols-mode)
            (eldoc-mode)
            (yas-minor-mode)
            (company-mode)
            (smartparens-strict-mode)
            (rainbow-delimiters-mode)))
#+END_SRC

** Html
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :defer t
    :ensure t
  )
#+END_SRC
 
** Markdown mode
*** Markdown settings
#+begin_src emacs-lisp
    (use-package markdown-mode
      :ensure t
      :defer t
      :mode (("\\.markdown\\'" . markdown-mode)
             ("\\.md\\'"       . markdown-mode))
      :init
      (progn
        (setq markdown-command "pandoc -s -N -V mainfont=Optima --latex-engine=xelatex --smart --bibliography=/Users/Roambot/Dropbox/Work/Master.bib --template=/Users/Roambot/.pandoc/pandoc-templates/default.latex -o '%.pdf' '%'"
              markdown-enable-math t
              markdown-footnote-location "immediately"
              markdown-nested-imenu-heading-index t
              markdown-open-command "/Users/Roambot/bin/scripts/mark.sh"
              )
         (global-git-gutter+-mode t)
         (add-hook 'markdown-mode-hook #'markdown-auto-fill)
         (add-hook 'markdown-mode-hook #'centered-cursor-mode) 
         (add-hook 'markdown-mode-hook #'pandoc-mode) 
         (add-hook 'markdown-mode-hook #'hl-todo-mode) 
         (add-hook 'markdown-mode-hook #'flyspell-mode)
         ;; add keybindings to hook
         (add-hook 'markdown-mode-hook #'my-markdown-config))
       :config
       (progn
         ;; Header navigation in normal state movements
         (evil-define-key 'normal markdown-mode-map
            "gj" 'outline-forward-same-level
            "gk" 'outline-backward-same-level
            "gh" 'outline-up-heading
            ;; next visible heading is not exactly what we want but close enough
            "gl" 'outline-next-visible-heading)
            ;; "<return>" 'markdown-jump

         ;; Promotion, Demotion
          (define-key markdown-mode-map (kbd "M-h") 'markdown-promote)
          (define-key markdown-mode-map (kbd "M-j") 'markdown-move-down)
          (define-key markdown-mode-map (kbd "M-k") 'markdown-move-up)
          (define-key markdown-mode-map (kbd "M-l") 'markdown-demote)
          ;; (define-key markdown-mode-map (kbd "<return>") 'markdown-jump)
    ))

    ;; markdown hooks
  (add-hook 'markdown-mode-hook
            '(lambda()
               (turn-on-auto-fill) (linum-mode) (centered-cursor-mode) (set-fill-column 80) (flyspell-mode 1) (pandoc-mode) (hl-todo-mode) (global-git-gutter+-mode t)))

  ;; autofill for markdown
  (defun markdown-auto-fill ()
    "turn on autofill and settings"
    (turn-on-auto-fill)
    (set-fill-column 80))
#+end_src

*** Pandoc
Pandoc mode for markdown conversion
#+BEGIN_SRC emacs-lisp
  (use-package pandoc-mode
    :ensure t
    :defer t  
    :config
    (progn
      (defun run-pandoc ()
        "Start pandoc for the buffer and open the menu"
        (interactive)
        (pandoc-mode)
        (pandoc-main-hydra/body))
      (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings)

      (defun pandoc-pdf-open ()
        "Open created PDF file"  
        (interactive)
        (find-file (concat (file-name-sans-extension buffer-file-name) ".pdf")))
        )
    :init
    (progn
      (setq pandoc-data-dir "~/.emacs.d/pandoc-mode/")
      ;; help pandoc find xelatex
      (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin"))
      (evil-leader/set-key "up" 'run-pandoc)
      (evil-leader/set-key "uP" 'pandoc-pdf-open)))
#+END_SRC

*** Critic markup
Disabled due to errors
#+BEGIN_SRC emacs-lisp
  (use-package cm-mode
    :defer t
    :ensure t
    :disabled t ;; causes font-lock error in markdown mode
    :init
    (add-hook 'markdown-mode-hook 'cm-mode))
#+END_SRC
** Shell scripts
#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :defer t
    :ensure t
    :init
    (progn
      (defun emacs//setup-shell ()
        (when (and buffer-file-name
                   (string-match-p "\\.zsh\\'" buffer-file-name))
          (sh-set-shell "zsh")))
      (add-hook 'sh-mode-hook 'emacs//setup-shell)))
#+END_SRC
 
** Yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :defer t
    :config
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
    (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
    (add-hook 'yaml-mode-hook (lambda () (run-hooks 'prog-mode-hook)))
  )
#+END_SRC
** Vim
#+BEGIN_SRC emacs-lisp
  (use-package vimrc-mode
    :ensure t
    :defer t)
#+END_SRC
* Useful functions
** Org wrap in block template
A helpful function I found [[http://pragmaticemacs.com/emacs/wrap-text-in-an-org-mode-block/][here]] for wrapping text in a block template. 
#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; function to wrap blocks of text in org templates                       ;;
;; e.g. latex or src etc                                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun org-block-wrap ()
  "Make a template at point."
  (interactive)
  (if (org-at-table-p)
      (call-interactively 'org-table-rotate-recalc-marks)
    (let* ((choices '(("s" . "SRC")
                      ("E" . "SRC emacs-lisp")
                      ("e" . "EXAMPLE")
                      ("q" . "QUOTE")
                      ("v" . "VERSE")
                      ("c" . "CENTER")
                      ("l" . "LaTeX")
                      ("h" . "HTML")
                      ("a" . "ASCII")))
           (key
            (key-description
             (vector
              (read-key
               (concat (propertize "Template type: " 'face 'minibuffer-prompt)
                       (mapconcat (lambda (choice)
                                    (concat (propertize (car choice) 'face 'font-lock-type-face)
                                            ": "
                                            (cdr choice)))
                                  choices
                                  ", ")))))))
      (let ((result (assoc key choices)))
        (when result
          (let ((choice (cdr result)))
            (cond
             ((region-active-p)
              (let ((start (region-beginning))
                    (end (region-end)))
                (goto-char end)
                (insert "#+END_" choice "\n")
                (goto-char start)
                (insert "#+BEGIN_" choice "\n")))
             (t
              (insert "#+BEGIN_" choice "\n")
              (save-excursion (insert "#+END_" choice))))))))))

#+end_src
** Resume last search
#+BEGIN_SRC emacs-lisp
  (defun last-search-buffer ()
        "open last helm-ag or hgrep buffer."
        (interactive)
        (cond ((get-buffer "*helm ag results*")
               (switch-to-buffer-other-window "*helm ag results*"))
              ((get-buffer "*helm-ag*")
               (helm-resume "*helm-ag*"))
              ((get-buffer "*hgrep*")
               (switch-to-buffer-other-window "*hgrep*"))
              (t
               (message "No previous search buffer found"))))
#+END_SRC
** Rotate windows
#+BEGIN_SRC emacs-lisp
;; from magnars modified by ffevotte for dedicated windows support
(defun rotate-windows (count)
  "Rotate your windows.
Dedicated windows are left untouched. Giving a negative prefix
argument takes the kindows rotate backwards."
  (interactive "p")
  (let* ((non-dedicated-windows (remove-if 'window-dedicated-p (window-list)))
         (num-windows (length non-dedicated-windows))
         (i 0)
         (step (+ num-windows count)))
    (cond ((not (> num-windows 1))
           (message "You can't rotate a single window!"))
          (t
           (dotimes (counter (- num-windows 1))
             (let* ((next-i (% (+ step i) num-windows))

                    (w1 (elt non-dedicated-windows i))
                    (w2 (elt non-dedicated-windows next-i))

                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))

                    (s1 (window-start w1))
                    (s2 (window-start w2)))
               (set-window-buffer w1 b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)
               (setq i next-i)))))))

(defun rotate-windows-backward (count)
  "Rotate your windows backward."
  (interactive "p")
  (spacemacs/rotate-windows (* -1 count)))
#+END_SRC
** Open projects directory
#+BEGIN_SRC emacs-lisp
  (defun goto-projects ()
      "Open projects dir"
      (interactive)
      (require 'ranger)
      (find-file "~/projects"))

#+END_SRC
** Search directories with ag
#+BEGIN_SRC emacs-lisp
  (defun cpm/helm-files-do-ag (&optional dir)
        "Search in files with `ag' using a default input."
        (interactive)
        (helm-do-ag dir))
#+END_SRC
** Jump in buffer
I got this from the [[https://github.com/syl20bnr/spacemacs/blob/5f26b82e1abdde81cdf7cd17ba06f64db2343667/layers/%2Bdistribution/spacemacs-base/funcs.el][spacemacs config]]. Useful for navigating in tagged buffers. 
#+BEGIN_SRC emacs-lisp
(defun jump-in-buffer ()
  (interactive)
  (cond
   ((eq major-mode 'org-mode)
    (call-interactively 'helm-org-in-buffer-headings))
   (t
    (call-interactively 'helm-semantic-or-imenu))))
#+END_SRC
** Other functions
Most of these are from the [[https://github.com/syl20bnr/spacemacs][spacemacs]] distribution.
#+BEGIN_SRC emacs-lisp
  ;; Regexp for useful and useless buffers for smarter buffer switching, from spacemacs

  (defvar spacemacs-useless-buffers-regexp '("*\.\+")
    "Regexp used to determine if a buffer is not useful.")
  (defvar spacemacs-useful-buffers-regexp '("\\*\\(scratch\\|terminal\.\+\\|ansi-term\\|eshell\\)\\*")
    "Regexp used to define buffers that are useful despite matching
  `spacemacs-useless-buffers-regexp'.")

  (defun spacemacs/useless-buffer-p (buffer)
    "Determines if a buffer is useful."
    (let ((buf-paren-major-mode (get (with-current-buffer buffer
                                       major-mode)
                                     'derived-mode-parent))
          (buf-name (buffer-name buffer)))
      ;; first find if useful buffer exists, if so returns nil and don't check for
      ;; useless buffers. If no useful buffer is found, check for useless buffers.
      (unless (cl-loop for regexp in spacemacs-useful-buffers-regexp do
                       (when (or (eq buf-paren-major-mode 'comint-mode)
                                 (string-match regexp buf-name))
                         (return t)))
        (cl-loop for regexp in spacemacs-useless-buffers-regexp do
                 (when (string-match regexp buf-name)
                   (return t))))))

  (defun spacemacs/next-useful-buffer ()
    "Switch to the next buffer and avoid special buffers."
    (interactive)
    (let ((start-buffer (current-buffer)))
      (next-buffer)
      (while (and (spacemacs/useless-buffer-p (current-buffer))
                  (not (eq (current-buffer) start-buffer)))
        (next-buffer))))

  (defun spacemacs/previous-useful-buffer ()
    "Switch to the previous buffer and avoid special buffers."
    (interactive)
    (let ((start-buffer (current-buffer)))
      (previous-buffer)
      (while (and (spacemacs/useless-buffer-p (current-buffer))
                  (not (eq (current-buffer) start-buffer)))
        (previous-buffer))))

  ;; from magnars
  (defun spacemacs/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (cond ((get-buffer new-name)
                 (error "A buffer named '%s' already exists!" new-name))
                (t
                 (let ((dir (file-name-directory new-name)))
                   (when (and (not (file-exists-p dir)) (yes-or-no-p (format "Create directory '%s'?" dir)))
                     (make-directory dir t)))
                 (rename-file filename new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil)
                 (when (fboundp 'recentf-add-file)
                     (recentf-add-file new-name)
                     (recentf-remove-if-non-kept filename))
                 (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

  ;; from magnars
  (defun spacemacs/delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to delete this file? ")
          (delete-file filename t)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
        
  ;; found at http://emacswiki.org/emacs/KillingBuffers
  (defun spacemacs/kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (when (yes-or-no-p (format "Killing all buffers except \"%s\"? " (buffer-name)))
      (mapc 'kill-buffer (delq (current-buffer) (buffer-list)))
      (message "Buffers deleted!")))

  ;; http://camdez.com/blog/2013/11/14/emacs-show-buffer-file-name/
  (defun spacemacs/show-and-copy-buffer-filename ()
    "Show the full path to the current file in the minibuffer."
    (interactive)
    (let ((file-name (buffer-file-name)))
      (if file-name
          (progn
            (message file-name)
            (kill-new file-name))
        (error "Buffer not visiting a file"))))

  (defun spacemacs/new-empty-buffer ()
    "Create a new buffer called untitled(<n>)"
    (interactive)
    (let ((newbuf (generate-new-buffer-name "untitled")))
      (switch-to-buffer newbuf)))

  ;; from https://github.com/gempesaw/dotemacs/blob/emacs/dg-defun.el
  (defun spacemacs/kill-matching-buffers-rudely (regexp &optional internal-too)
    "Kill buffers whose name matches the specified REGEXP. This
  function, unlike the built-in `kill-matching-buffers` does so
  WITHOUT ASKING. The optional second argument indicates whether to
  kill internal buffers too."
    (interactive "sKill buffers matching this regular expression: \nP")
    (dolist (buffer (buffer-list))
      (let ((name (buffer-name buffer)))
        (when (and name (not (string-equal name ""))
                   (or internal-too (/= (aref name 0) ?\s))
                   (string-match regexp name))
          (kill-buffer buffer)))))

  ;; http://stackoverflow.com/a/10216338/4869
  (defun spacemacs/copy-whole-buffer-to-clipboard ()
    "Copy entire buffer to clipboard"
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun spacemacs/copy-clipboard-to-whole-buffer ()
    "Copy clipboard and replace buffer"
    (interactive)
    (delete-region (point-min) (point-max))
    (clipboard-yank)
    (deactivate-mark))

  (defun spacemacs/copy-file ()
    "Write the file under new name."
    (interactive)
    (call-interactively 'write-file))
#+END_SRC
* Keybindings
I use a lot of keybindings, with <SPC> as my "leader" key
** Applications
#+BEGIN_SRC emacs-lisp
(which-key-declare-prefixes "<SPC>a" "Applications")
(evil-leader/set-key
"ad" 'deer
"am" 'multi-term
"ar" 'ranger
"as" 'sane-term
)
#+END_SRC
** Commenting
#+BEGIN_SRC emacs-lisp
(which-key-declare-prefixes "<SPC>c" "Commenting")
(evil-leader/set-key
  "cb" 'org-block-wrap
  "cc" 'evil-commentary
  "cl" 'evil-commentary-line
  "cy" 'evil-commentary-yank-line
 )
#+END_SRC
 
** Config
#+BEGIN_SRC emacs-lisp
  (defun goto-init.el ()
      "Open init.el file"
      (interactive)
      (find-file "~/.emacs.d/init.el"))
  (defun goto-custom.el ()
      "Open custom.el file"
      (interactive)
      (find-file "~/.emacs.d/custom.el"))
  (defun goto-config.org ()
      "Open config.org file"
      (interactive)
      (find-file "~/.emacs.d/config.org"))
  (defun load-config.org ()
      "Load config.org using org-babel"
      (interactive)
      (org-babel-load-file "~/.emacs.d/config.org"))
  (which-key-declare-prefixes "<SPC>C" "Config")
  (evil-leader/set-key
    "Cc" 'goto-config.org
    "Cl" 'tangle-init
    "Cd" 'load-config.org
    "Cs" 'goto-custom.el
    "Ci" 'goto-init.el
  )

#+END_SRC
** Buffers
#+BEGIN_SRC emacs-lisp
    (which-key-declare-prefixes "<SPC>b" "Buffers")
    (evil-leader/set-key
      "bb" 'helm-mini
      "bB" 'helm-buffers-list
      "bc" 'spacemacs/new-empty-buffer
      "bD" 'kill-buffer-and-window
      "bd" 'kill-this-buffer
      "bf" 'reveal-in-osx-finder
      ;; "bj" 'jump-in-buffer 
      "bk" 'evil-delete-buffer
      "bK" 'spacemacs/kill-other-buffers
      "bn" 'spacemacs/new-empty-buffer
      "br" 'revert-buffer
      "bR" 'spacemacs/rename-current-buffer-file
      "bt" 'open-dir-in-iterm
  )

#+END_SRC

** Files
#+BEGIN_SRC emacs-lisp
  (which-key-declare-prefixes "<SPC>f" "Files")
  (evil-leader/set-key
    "ff" 'helm-find-files
    ;; "ff" 'counsel-find-files
    ;; "fl" 'counsel-locate
    "fl" 'helm-locate
    "fs" 'save-buffer
    "fr" 'helm-recentf
    "fy" 'spacemacs/show-and-copy-buffer-filename
      )

#+END_SRC

** General
#+BEGIN_SRC emacs-lisp
  (evil-leader/set-key
    "A" 'helm-apropos
    "?" 'helm-descbinds
    "<SPC>" 'helm-M-x
    "d" 'deer
    "e" 'server-edit
    "h" 'helm-resume
    "j" 'ace-jump-mode
    "k" 'helm-show-kill-ring
    "n" 'cpm/deft
    "W" 'woman
    ";" 'evil-commentary-line
    "[" 'spacemacs/previous-useful-buffer
    "]" 'spacemacs/next-useful-buffer
    "TAB" 'switch-to-previous-buffer)
#+END_SRC
** Markdown mode
#+BEGIN_SRC emacs-lisp
(defun my-markdown-config ()
  "Modify keymaps in markdown mode"
  (which-key-declare-prefixes "<SPC>m" "Markdown")
  (which-key-declare-prefixes "<SPC>mc" "command")
  (which-key-declare-prefixes "<SPC>mh" "insert")
  (which-key-declare-prefixes "<SPC>mi" "lists")
  (which-key-declare-prefixes "<SPC>mx" "text")
  (evil-leader/set-key
        ;; Movement
        "m{"   'markdown-backward-paragraph
        "m}"   'markdown-forward-paragraph
        ;; Completion, and Cycling
        "m]"   'markdown-complete
        ;; Indentation
        "m>"   'markdown-indent-region
        "m<"   'markdown-exdent-region
        ;; Buffer-wide commands
        "mc]"  'markdown-complete-buffer
        "mcc"  'markdown-check-refs
        "mce"  'markdown-export
        "mcm"  'markdown-other-window
        "mcn"  'markdown-cleanup-list-numbers
        "mco"  'markdown-open
        "mcp"  'markdown-preview
        "mcv"  'markdown-export-and-preview
        "mcw"  'markdown-kill-ring-save
        ;; headings
        "mhi"  'markdown-insert-header-dwim
        "mhI"  'markdown-insert-header-setext-dwim
        "mh1"  'markdown-insert-header-atx-1
        "mh2"  'markdown-insert-header-atx-2
        "mh3"  'markdown-insert-header-atx-3
        "mh4"  'markdown-insert-header-atx-4
        "mh5"  'markdown-insert-header-atx-5
        "mh6"  'markdown-insert-header-atx-6
        "mh!"  'markdown-insert-header-setext-1
        "mh@"  'markdown-insert-header-setext-2
        ;; Insertion of common elements
        "m-"   'markdown-insert-hr
        "mif"  'markdown-insert-footnote
        "mii"  'markdown-insert-image
        "mik"  'spacemacs/insert-keybinding-markdown
        "miI"  'markdown-insert-reference-image
        "mil"  'markdown-insert-link
        "miL"  'markdown-insert-reference-link-dwim
        "miw"  'markdown-insert-wiki-link
        "miu"  'markdown-insert-uri
        ;; Element removal
        "mk"   'markdown-kill-thing-at-point
        ;; List editing
        "mli"  'markdown-insert-list-item
        ;; region manipulation
        "mxb"  'markdown-insert-bold
        "mxi"  'markdown-insert-italic
        "mxc"  'markdown-insert-code
        "mxC"  'markdown-insert-gfm-code-block
        "mxq"  'markdown-insert-blockquote
        "mxQ"  'markdown-blockquote-region
        "mxp"  'markdown-insert-pre
        "mxP"  'markdown-pre-region
        ;; Following and Jumping
        "mN"   'markdown-next-link
        "mf"   'markdown-follow-thing-at-point
        "mP"   'markdown-previous-link
   ))
   

#+END_SRC

** Miscellaneous
#+BEGIN_SRC emacs-lisp
;; Show which-key top-level bindings
(global-set-key (kbd "H-k") 'which-key-show-top-level)
#+END_SRC
 
** User
#+BEGIN_SRC emacs-lisp
  (defun cpm/org-to-markdown ()
    "convert clipboard contents from org to markdown and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f org -t markdown"))
    (yank))

  (defun cpm/markdown-to-org ()
    "convert clipboard contents from markdown to org and paste"
    (interactive)
    (kill-new (shell-command-to-string "osascript -e 'the clipboard as unicode text' | pandoc -f markdown -t org"))
    (yank))

  (which-key-declare-prefixes "<SPC>u" "User")
  (evil-leader/set-key
   "um" 'cpm/org-to-markdown   
   "uo" 'cpm/markdown-to-org
   "us" 'sb-expand-current-file
   "uS" 'just-one-space
   "ud" 'distraction-free
   "uD" 'osx-dictionary-search-input
   ;; "op" 'pandoc-convert-to-pdf
   "uw" 'count-words
   "ux" 'helm-bibtex
    )

#+END_SRC
 
** Org Mode
Keybindings for org mode 
#+BEGIN_SRC emacs-lisp
    (defun cpm/org-keybindings ()
      "Modify keymaps for mode 'm' in org mode"
      (which-key-declare-prefixes "<SPC>o" "Org")
      (which-key-declare-prefixes "<SPC>oa" "agenda")
      (which-key-declare-prefixes "<SPC>ot" "tree")
      (evil-leader/set-key
      ;; org tree
      "otn" 'org-narrow-to-subtree
      "otw" 'widen
      "ott" 'org-show-todo-tree
      "oaa" 'org-agenda
      "oc"  'org-archive-subtree
      "ol"  'evil-org-open-links
      "oo"  'evil-org-recompute-clocks
      "oP"  'org-publish-current-project
      "op"  'org-publish-current-file
      )

  ;; normal state shortcuts
  (evil-define-key 'normal org-mode-map
    "gh" 'outline-up-heading
    "gp" 'outline-previous-heading
    "gj" (if (fboundp 'org-forward-same-level) ;to be backward compatible with older org version
         'org-forward-same-level
        'org-forward-heading-same-level)
    "gk" (if (fboundp 'org-backward-same-level)
         'org-backward-same-level
        'org-backward-heading-same-level)
    "gl" 'outline-next-visible-heading
    "t" 'org-todo
    "H" 'org-shiftleft
    ;; "" 'org-shiftdown
    ;; "" 'org-shiftup
    "L" 'org-shiftright
    "$" 'org-end-of-line
    "^" 'org-beginning-of-line
    "<" 'org-metaleft
    ">" 'org-metaright
    "-" 'org-cycle-list-bullet
    (kbd "<tab>") 'org-cycle)

  ;; normal & insert state shortcuts.
  (mapc (lambda (state)
          (evil-define-key state org-mode-map
            (kbd "M-l") 'org-metaright
            (kbd "M-h") 'org-metaleft
            (kbd "M-k") 'org-metaup
            (kbd "M-j") 'org-metadown
            (kbd "M-L") 'org-shiftmetaright
            (kbd "M-H") 'org-shiftmetaleft
            (kbd "M-K") 'org-shiftmetaup
            (kbd "M-J") 'org-shiftmetadown
            ))
        '(normal insert))

  )
#+END_SRC
** Packages
Keybindings for managing packages
#+BEGIN_SRC emacs-lisp
  (which-key-declare-prefixes "<SPC>P" "Packages")
  (evil-leader/set-key
    "Pl" 'paradox-list-packages
    "Pu" 'paradox-upgrade-packages
    )
#+END_SRC
** Projects
#+BEGIN_SRC emacs-lisp
(which-key-declare-prefixes "<SPC>p" "Projects")
(evil-leader/set-key 
  "p!" 'projectile-run-shell-command-in-root
  "p&" 'projectile-run-async-shell-command-in-root
  "pa" 'projectile-toggle-between-implementation-and-test
  "pb"  'helm-projectile-switch-to-buffer
  "pc" 'projectile-compile-project
  "pd"  'helm-projectile-find-dir
  "pD" 'projectile-dired
  "pf"  'helm-projectile-find-file
  "pg" 'goto-projects
  "ph"  'helm-projectile
  "pG" 'projectile-regenerate-tags
  "pI" 'projectile-invalidate-cache
  "pk" 'projectile-kill-buffers
  "po" 'projectile-multi-occur
  "pp"  'helm-projectile-switch-project
  "pr"  'helm-projectile-recentf
  "pR" 'projectile-replace
  "pT" 'projectile-find-test-file
  "pv"  'projectile-vc
  "py" 'projectile-find-tag
  "sgp" 'helm-projectile-grep
)
#+END_SRC
** Search
#+BEGIN_SRC emacs-lisp
  (which-key-declare-prefixes "<SPC>s" "Search")
  (evil-leader/set-key
    "ss" 'helm-swoop-without-pre-input ;; search in file
    "sp" 'helm-ag-project-root
    "so" 'helm-occur
    "sd" 'helm-do-ag ;; search with directory prompt
    "sj" 'jump-in-buffer
    "/"  'helm-ag  ;; search in directory with word prompt
    "sl" 'last-search-buffer
   )
#+END_SRC
 
** Toggles
#+BEGIN_SRC emacs-lisp
(which-key-declare-prefixes "<SPC>t" "Toggles")
(evil-leader/set-key
  "ta" 'company-mode
  "tb" 'fancy-battery-mode
  "tc" 'centered-cursor-mode
  "td" 'centered-window-mode
  "tf" 'toggle-frame-fullscreen
  "tg" 'git-gutter+-mode
  "th" 'global-hl-line-mode
  "te" 'toggle-indicate-empty-lines
  "tE" 'eldoc-mode
  "tm" 'spaceline-toggle-minor-modes
  "tn" 'linum-mode
  "to" 'org-toggle-link-display
  "tp" 'smartparens-mode
  "tr" 'rainbow-identifiers-mode
  "tt" 'helm-themes
)
#+END_SRC

** Windows


#+BEGIN_SRC emacs-lisp
(which-key-declare-prefixes "<SPC>w" "Windows")
(evil-leader/set-key
  "wc" 'delete-window
  "w-" 'evil-window-split
  "w_" 'split-window-below-and-focus
  "wr" 'rotate-windows
  "wR" 'rotate-windows-backward
  "wv" 'split-window-right-and-focus
  "wV" 'evil-window-vsplit
  "wm" 'delete-other-windows
  )
#+END_SRC

** Quitting
#+BEGIN_SRC emacs-lisp
    (which-key-declare-prefixes "<SPC>q" "Quit")
    (evil-leader/set-key
    "qq" 'evil-quit-all
    "qr" 'restart-emacs)
#+END_SRC
* Test code
#+BEGIN_SRC emacs-lisp
#+END_SRC
* Server
Start server
#+BEGIN_SRC emacs-lisp
  (use-package server
    :init
    (when window-system
      (unless (server-running-p)
        (add-hook 'after-init-hook 'server-start t)))
    )
#+END_SRC
